<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言程序设计概述</title>
    <url>/posts/c5a3/</url>
    <content><![CDATA[<h1 id="C语言程序设计概述"><a href="#C语言程序设计概述" class="headerlink" title="C语言程序设计概述"></a>C语言程序设计概述</h1><h2 id="1-C语言的发展历程"><a href="#1-C语言的发展历程" class="headerlink" title="1.C语言的发展历程"></a>1.C语言的发展历程</h2><ul>
<li>1.为什么发明C语言：C语言的诞生是和UNIX操作系统的开发密不可分的，原先的UNⅨX操作系统都是用汇编语言写的，1973年UNIX操作系统的核心用C语言改写，从此以后，C语言成为编写操作系统的主要语言</li>
<li>2.C语言对其它语言的影响：很多编程语言都深受C语言的影响，比如C艹（原先是C语言的一个扩展）、C#、 Java、PHP、 Javascript、Perl、LPC和UNIX的 C Shell等</li>
<li>掌握C语言的人，再学其它编程语言，大多能很快上手，触类旁通，很多大学将C语言作为计算机教学的入门</li>
<li>C语言之父 <strong>丹尼斯·麦卡利斯泰尔·里奇</strong>（英语：<strong>Dennis MacAlistair Ritchie</strong></li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200703203727.png" alt="1-15030119511M02"></p>
<p><strong>程序：</strong></p>
<ul>
<li>为了<code>计算机</code><strong>执行某些操作或解决某个问题</strong>而编写的一系列<strong>有序指令的集合</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio h&gt;</span></span></span><br><span class="line"><span class="comment">//main函数，是程序的执行入口，即程序是从main函数开始执行</span></span><br><span class="line"><span class="comment">//void表示main函数没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="comment">//printf是一个函数，需要是一个头文件才能使用</span></span><br><span class="line">    <span class="comment">//printf是在&lt; stdio. h&gt;，需要引入该头文件</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello, world!"</span>);</span><br><span class="line">    <span class="comment">//让窗口停留</span></span><br><span class="line">    getchar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-C语言的特点"><a href="#2-C语言的特点" class="headerlink" title="2.C语言的特点"></a>2.C语言的特点</h2><ul>
<li>代码级别的<strong>跨平台</strong>：由于标准的存在，使得几乎同样的C代码可用于多种操作系统，如 Windows、DOS、UNIX等等；也适用于多种机型。</li>
<li><strong>允许直接访问物理地址</strong>，<strong>对硬件进行操作</strong> 因此它<strong>既具有高级语言的功能</strong>，<strong>又具有低级语言的许多功能</strong>，C语言可用来写系统软件（比如操作系统，数据库，杀毒软件，防火墙，驱动，服务器程序）。</li>
<li>C语言是一个有<strong>结构化程序设计</strong>、具有<strong>变量作用域（ variable scope）</strong>以及<strong>递归功能</strong>的过程式语言</li>
<li>C语言<code>传递参数</code>可以是<code>值传递</code>（ pass by value，值），也可以<code>传递指针</code>（ a pointer passed by value，地址）也叫<code>引用传递</code></li>
<li>C语言中，没有对象，不同的变量类型可以用结构体（ struct）组合在一起</li>
<li>预编译处理（ preprocessor），生成目标代码质量高，程序执行效率高</li>
</ul>
<h2 id="3-C语言运行机制"><a href="#3-C语言运行机制" class="headerlink" title="3.C语言运行机制"></a>3.C语言运行机制</h2><p><strong>C程序运行机制过程</strong></p>
<ul>
<li><p>1.编辑：比如编写我们的 hello. c文件，就是<code>源代码</code>,</p>
</li>
<li><p>2.编译：将 <code>hello.c</code>程序通过编译器将其编译成<code>目标文件(hell.obj)</code>在<strong>计算机底层</strong>执行</p>
</li>
<li><p>3.链接：将目标文件 hello. obj + <code>库文件</code>生成可执行文件(My ProjectoR.exe)<strong>计算机底层</strong>执行</p>
<p>链接库文件的原因：我们的C程序中会使用<code>C程序库</code>的内容，比如&lt; stdio.h&gt;&lt; stdlib. h&gt;中的函数printf system（）等等，这些函数不是程序员自己写的，而是C程序库中提供的,</p>
<p>链接链接后，生成的exe文件，会比obj文件更大</p>
</li>
<li><p>4.运行：执行<code>exe</code>文件，得到运行结果</p>
<p>​                                            <strong>运行机制图解</strong></p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200704093956.png" alt="image-20200704093722914"></p>
<h2 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h2><table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>一个制表符,用于格式对齐</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\\</td>
<td>表示一个\反斜杠</td>
</tr>
<tr>
<td>\“</td>
<td>表示一个”</td>
</tr>
<tr>
<td>\‘</td>
<td>表示一个’</td>
</tr>
<tr>
<td>\r</td>
<td>表示回车</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=4" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
<a class="btn-beautify button--animated outline green larger" href="https://www.runoob.com/cprogramming/c-standard-library.html" target="_blank" rel="noopener" title="C语言标准库参考手册"><i class="far fa-hand-point-right fa-fw"></i> C语言标准库参考手册 </a>
</div>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象的三大特性</title>
    <url>/posts/ac27/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Github下载加速</title>
    <url>/posts/79ca/</url>
    <content><![CDATA[<p><strong>准备条件</strong></p>
<ul>
<li>码云(Gitee账号)</li>
</ul>
<p>注册地址：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></p>
<ul>
<li>Git</li>
</ul>
<p>镜像下载地址：<a href="https://npm.taobao.org/mirrors/git-for-windows" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows</a></p>
<h2 id="1-码云-Gitee-导入"><a href="#1-码云-Gitee-导入" class="headerlink" title="1.码云(Gitee)导入"></a>1.码云(Gitee)导入</h2><p>1.以<code>Github</code>上Stars较多的一个优秀的Java学习路线项目为例</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/6e61b1ed8495188950dfd0b73705b957.png" alt="image-20200630113350201"></p>
<blockquote>
<p>1.复制项目的网址</p>
</blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/b5928fa75fe216915bfa5f0611796b28.png" alt="image-20200630113456261"></p>
<blockquote>
<p>2.导入项目到Gitee</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/d2e4a08b94327d6b0ce9569607ee63f2.png" alt="image-20200630113727080"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/1202564fd464d7efa445f44a5679d0a8.png" alt="image-20200630114432345"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/4d52e8150d9f81182e386a8882d4d70f.png" alt="image-20200630114647419"></p>
<p><strong>导入后等待页面加载即可</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/88d8e95cbbe78cb93e8c43f00cf92f57.png" alt="image-20200630114914779"></p>
<p><strong>将项目克隆到本地</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/ecd4d35e1eac4e6a71efe1089f855fbd.png" alt="image-20200630115427594"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#git clone 码云上的项目地址</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/crow_678/JavaGuide.git</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/10b6c23c7bbcfddebbd608468a2754ff.png" alt="image-20200630115535023"></p>
<p><strong>速度还行</strong></p>
<p><strong>当我们导入一个比较大的项目时</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/71747e5f946516ec19148fcfd9003832.png" alt="image-20200630120819524"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/e702ecef3ef4897a5a88f509587c1494.png" alt="image-20200630121226310"></p>
<h2 id="2-使用在线的网站"><a href="#2-使用在线的网站" class="headerlink" title="2.使用在线的网站"></a>2.使用在线的网站</h2><p><a href="http://g.widyun.com/" target="_blank" rel="noopener">http://g.widyun.com/</a></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/7aa20b8396ecd033331e7199c956bd3f.png" alt="image-20200630121331482"></p>
<p><strong>复制项目网址到中间的输入框,点击获取连接耐心等待</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/b7cdf7a2b2fb2ccbb03901b77a6352ce.png" alt="image-20200630122021103"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/30/62fcf183c409d8fb19fae2201204522a.png" alt="image-20200630122104574"></p>
]]></content>
      <categories>
        <category>生产力</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA快捷键</title>
    <url>/posts/aa80/</url>
    <content><![CDATA[<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><p><a href="https://www.cnblogs.com/xiemingjun/p/9618427.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiemingjun/p/9618427.html</a></p>
]]></content>
      <categories>
        <category>生产力</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/posts/f1de/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象的三大特性</title>
    <url>/posts/9d0/</url>
    <content><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>参考链接</li>
<li><a href="https://www.cnblogs.com/chenssy/p/3351835.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenssy/p/3351835.html</a></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>参考链接</li>
<li><a href="https://www.cnblogs.com/chenssy/p/3354884.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenssy/p/3354884.html</a></li>
</ul>
<p>##多态</p>
<ul>
<li>参考链接</li>
<li><a href="https://www.cnblogs.com/chenssy/p/3372798.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenssy/p/3372798.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/posts/46eb/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring全家桶</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/posts/5257/</url>
    <content><![CDATA[<h1 id="集合分类："><a href="#集合分类：" class="headerlink" title="集合分类："></a>集合分类：</h1><p><strong>List,Set,Map三者的区别</strong></p>
<p><strong>List(顺序)</strong>： List接⼝存储⼀组不唯⼀（可以有<strong>多个元素引⽤相同的对象</strong>），<strong>有序</strong>的对象</p>
<p><strong>Set(不重复):</strong> 不允许重复的集合。<strong>不会有多个元素引⽤相同的对象。</strong></p>
<p><strong>Map(键Key):</strong> 使⽤<code>键值对</code>存储。Map会维护与Key有关联的值。<strong>两个Key可以引⽤相</strong></p>
<p><strong>同的对象</strong>，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200703152229.png" alt="image-20200703152225014"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="1-1ArrayList"><a href="#1-1ArrayList" class="headerlink" title="1.1ArrayList"></a>1.1ArrayList</h3><p><code>ArrayList</code>实现了<strong>长度可变的数组</strong>,数组<strong>元素类型为Object类型</strong>,即<strong>可以存放所有类型数据</strong>,内存中<strong>分配连续的空间</strong>。</p>
<ul>
<li><p><strong>遍历元素</strong>和<strong>随机访问元素</strong>的效率比较高  </p>
</li>
<li><p>构造ArrayList时；若使用<strong>默认构造函数</strong>，则ArrayList的<strong>默认容量大小是10。</strong></p>
</li>
<li><p>ArrayList<strong>容量不足以容纳全部元素</strong>时，ArrayList会<strong>重新设置容量</strong>：<strong>新的容量=“(原始容量x3)/2 + 1”。</strong></p>
</li>
<li><p>ArrayList实现``java.io.Serializable`的方式。当<strong>写入到输出流</strong>时，<strong>先写入“容量”</strong>，<strong>再依次写入“每一个元素”</strong>；当<strong>读出输入流</strong>时，<strong>先读取“容量”，再依次读取“每一个元素</strong></p>
</li>
</ul>
<p>​                                                                                     <strong>内存图解</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200703180004.png" alt="image-20200703154835792"></p>
<p><code>ArrayList</code>的常用方法</p>
<p><strong>增加</strong></p>
<ul>
<li><p><code>add();</code>  加入一个元素（Object）</p>
</li>
<li><p><code>addAll();</code> 加入集合元素（Collection）</p>
</li>
<li><p><code>add(index, element);</code>在指定位置添加元素&gt;</p>
</li>
</ul>
<p><strong>删除</strong></p>
<ul>
<li><code>remove(int index)</code>  通过索引删除<strong>指定位置</strong>的元素。 </li>
<li><code>remove(Object o)</code>  删除第一次出现的指定元素从这个列表,如果它存在。 </li>
</ul>
<p>注意重载</p>
<ul>
<li><code>removeAll(Collection c)</code>  从这个列表中移除所有元素包含在指定的集合</li>
</ul>
<p><strong>修改</strong></p>
<ul>
<li><code>set(index, element)</code>  取代<strong>指定位置</strong>上的元素</li>
</ul>
<p><strong>查询</strong></p>
<ul>
<li><p><code>size()</code> 查看<strong>集合的长度</strong>:</p>
</li>
<li><p><code>indexOf()</code>   通过索引查询指定元素 <strong>从前往后查</strong></p>
</li>
<li><p><code>lastIndexOf()</code>  通过索引查询指定元素,<strong>从后向前查找</strong></p>
</li>
<li><p><code>contains()</code>   判读集合中<strong>是否包含某个元素</strong></p>
</li>
</ul>
<p><strong>其他方法</strong></p>
<ul>
<li><code>subList(start, end)</code> 截取集合内的元素 （起始索引,结束索引）</li>
</ul>
<p><strong>遍历</strong></p>
<ul>
<li>for循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">			System.out.println(arrayList.get(i));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>foreach循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object o:arrayList) &#123;</span><br><span class="line">			System.out.println(o);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代器<code>Iterator</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = arrayList.iterator();</span><br><span class="line">	<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历ArrayList时，使用随机访问 (通过索引序号访问) 效率最高，而使用迭代器的效率最低</strong></p>
<p>🔗参考链接</p>
<ul>
<li><a href="https://blog.csdn.net/qq_43776742/article/details/91042479" target="_blank" rel="noopener">https://blog.csdn.net/qq_43776742/article/details/91042479</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/posts/83dd/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring全家桶</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/posts/a67e/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring全家桶</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/posts/12ac/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>后端框架</category>
        <category>Spring全家桶</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分区模型</title>
    <url>/posts/a132/</url>
    <content><![CDATA[<p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li><code>代码区</code>：存放函数体的<strong>二进制代码</strong>，由<strong>操作系统进行管理</strong></li>
<li><code>全局区</code>：存放<strong>全局变量</strong>和<strong>静态变量</strong>以及<strong>常量</strong></li>
<li><code>栈区</code>：<strong>编译器自动分配释放</strong>, 存放<strong>函数的参数值</strong>,<strong>局部变量</strong>等</li>
<li><code>堆区</code>：<strong>手动分配和释放,没有手动释放</strong>,程序结束时<strong>由操作系统回收</strong></li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p><strong>不同区域存放的数据，赋予不同的生命周期</strong>, 便于开发程序</p>
<h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为<strong>两个区域</strong></p>
<p><strong>代码区：</strong></p>
<ul>
<li>存放 CPU 执行的<strong>机器指令(二进制代码)</strong></li>
<li>代码区是<strong>共享</strong>的，共享的目的是<strong>对于频繁被执行的程序，内存中有一份代码即可</strong></li>
<li>代码区是<strong>只读</strong>的，使其只读的原因是<strong>防止程序意外地修改了它的指令</strong></li>
</ul>
<p><strong>全局区：</strong></p>
<ul>
<li><code>全局变量</code>和<code>静态变量</code>存放位置</li>
<li>全局区还包含了<code>常量区</code>, <code>字符串常量</code>和<code>其他常量</code>也存放在此.</li>
<li><strong>该区域的数据在程序结束后由操作系统释放</strong></li>
</ul>
<p><strong>🌰举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"局部变量a地址为： "</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"局部变量b地址为： "</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"全局变量g_a地址为： "</span> &lt;&lt;  &amp;g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"全局变量g_b地址为： "</span> &lt;&lt;  &amp;g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"静态变量s_a地址为： "</span> &lt;&lt; &amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"静态变量s_b地址为： "</span> &lt;&lt; &amp;s_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串常量地址为： "</span> &lt;&lt; &amp;<span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串常量地址为： "</span> &lt;&lt; &amp;<span class="string">"hello world1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"全局常量c_g_a地址为： "</span> &lt;&lt; &amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"全局常量c_g_b地址为： "</span> &lt;&lt; &amp;c_g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"局部常量c_l_a地址为： "</span> &lt;&lt; &amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"局部常量c_l_b地址为： "</span> &lt;&lt; &amp;c_l_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">局部变量a地址为： 0x66fe1c</span><br><span class="line">局部变量b地址为： 0x66fe18</span><br><span class="line">全局变量g_a地址为： 0x404010</span><br><span class="line">全局变量g_b地址为： 0x404014</span><br><span class="line">静态变量s_a地址为： 0x404018</span><br><span class="line">静态变量s_b地址为： 0x40401c</span><br><span class="line">字符串常量地址为： 0x405096</span><br><span class="line">字符串常量地址为： 0x4050a2</span><br><span class="line">全局常量c_g_a地址为： 0x405000</span><br><span class="line">全局常量c_g_b地址为： 0x405004</span><br><span class="line">局部常量c_l_a地址为： 0x66fe14</span><br><span class="line">局部常量c_l_b地址为： 0x66fe10</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>C++中在程序运行前分为<code>全局区</code>和<code>代码区</code></li>
<li><code>代码区</code>特点是<strong>共享和只读</strong></li>
<li><code>全局区</code>中存放<code>全局变量</code>、<code>静态变量</code>、<code>常量</code></li>
<li><code>常量区</code>中存放 <code>const修饰的全局常量</code>  和 <code>字符串常量</code></li>
</ul>
<h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><p><strong>栈区：</strong></p>
<ul>
<li>编译器<strong>自动分配释放内存</strong>, 存放函数的<code>参数值</code>,<code>局部变量</code>等</li>
<li>注意事项：<strong>不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</strong></li>
</ul>
<p><strong>🌰举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = func();</span><br><span class="line">	<span class="comment">//第一次可以打印吃结果的原因:编译器对数据进行了保留</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//再次使用指针在内存中对数据进行操作时,数据已经消失</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆区：</strong></p>
<ul>
<li><strong>手动分配释放</strong>,没有释放,<strong>程序结束时由操作系统回收</strong></li>
<li>C++中主要利用<strong>new在堆区开辟内存</strong></li>
</ul>
<p><strong>🌰举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>堆区数据<strong>手动管理开辟和释放</strong></li>
<li>堆区数据利用<strong>new关键字进行开辟内存</strong></li>
</ul>
<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><ul>
<li>C++中利用<code>new</code>操作符在堆区开辟数据</li>
<li>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <code>delete</code></li>
<li>语法：<code>new 数据类型</code></li>
<li><strong>new创建的数据，会返回该数据对应的类型的指针</strong></li>
</ul>
<p><strong>🌰举例：</strong>基本语法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>🌰举例：</strong>：开辟数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                    <strong>内存图解</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200712201259.png" alt="image-20200712200817949"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1et411b73Z?p=85" target="_blank" rel="noopener" title="黑马程序员C++教程"><i class="far fa-hand-point-right fa-fw"></i> 黑马程序员C++教程 </a>
</div>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存分区模型</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown使用指南</title>
    <url>/posts/9365/</url>
    <content><![CDATA[<h2 id="MarkDown使用指南"><a href="#MarkDown使用指南" class="headerlink" title="MarkDown使用指南"></a>MarkDown使用指南</h2><ul>
<li>待办事项</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>[x] This is a complete item</span><br><span class="line"><span class="bullet">- </span>[ ] This is an incomplete item</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> This is a complete item</li>
<li><input disabled="" type="checkbox"> This is an incomplete item</li>
</ul>
<p><font color = red size = 5>文字颜色</font></p>
<p><font face="黑体">我是黑体字</font></p>
<p><font face="微软雅黑">我是微软雅黑</font></p>
<p><font face="STCAIYUN">我是华文彩云</font></p>
<p><font color=red >我是红色</font></p>
<p><font color=#008000>我是绿色</font></p>
<p><font color=Blue>我是蓝色</font></p>
<p><font size=5>我是尺寸</font></p>
<p><font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown)" target="_blank" rel="noopener" title="官方文档"><i class="far fa-hand-point-right fa-fw"></i> 官方文档 </a>
</div>

]]></content>
      <categories>
        <category>生产力</category>
      </categories>
      <tags>
        <tag>生产力</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10快捷键</title>
    <url>/posts/e5dc/</url>
    <content><![CDATA[<p>1.创建虚拟桌面</p>
<p>Win+Alt+D / Win+Tab(可以通过鼠标操作虚拟桌面的创建、切换与删除)</p>
<p>Win+Ctrl+F4 关闭当前虚拟桌面</p>
<p>2.窗口最小化</p>
<p>Win+M 窗口最小化 Win+D 可在最小化全部窗口与恢复全部窗口状态 间自由切换</p>
<p>3.应用切换<br>Ctrl+Alt+Tab显示当前桌面运行的所有应用程序 Ctrl+Tab 切换任务</p>
<p>4.屏幕截图</p>
<p>Win + PrtSc/PrtSc /Win + Shift + S</p>
<p>5.任务管理器</p>
<p>Ctrl+Shift+Esc</p>
<p>6.文件资源管理器</p>
<p>Win+E </p>
<p>7.操作中心</p>
<p>win+A</p>
<p>8.打开设置</p>
<p>Win+I</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.jb51.net/os/win10/226560.html" target="_blank" rel="noopener" title="Win10快捷键大全"><i class="far fa-hand-point-right fa-fw"></i> Win10快捷键大全 </a>
</div>

]]></content>
      <categories>
        <category>生产力</category>
      </categories>
      <tags>
        <tag>Win10</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目推荐</title>
    <url>/posts/aaf6/</url>
    <content><![CDATA[<h2 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1.编程语言"></a>1.编程语言</h2><h3 id="1-1Java"><a href="#1-1Java" class="headerlink" title="1.1Java"></a>1.1Java</h3><ul>
<li>1.<code>JavaGuide</code></li>
</ul>
<p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<h2 id="2-数据结构和算法"><a href="#2-数据结构和算法" class="headerlink" title="2.数据结构和算法"></a>2.数据结构和算法</h2><p>2.1<code>fucking-algorithm</code></p>
<p><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">https://github.com/labuladong/fucking-algorithm</a></p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/posts/5409/</url>
    <content><![CDATA[<h2 id="函数的初步了解"><a href="#函数的初步了解" class="headerlink" title="函数的初步了解"></a>函数的初步了解</h2><ul>
<li><p>为完成某一功能的<strong>程序指令（语句）的集合</strong>称为<code>函数</code></p>
</li>
<li><p>在C语言中，函数分为：<code>自定义函数</code>、<code>系统函数</code></p>
<ul>
<li>C语言在线手册 <a href="http://www.dba.cn/book/c/CJiChuJiaoCheng/CJiBenYuFa.html" target="_blank" rel="noopener">http://www.dba.cn/book/c/CJiChuJiaoCheng/CJiBenYuFa.html</a></li>
</ul>
</li>
<li><p>函数还有其它名称，方法等</p>
</li>
</ul>
<p><strong>函数的基本语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回类型 函数名 (形参)&#123;</span><br><span class="line">	执行语句;</span><br><span class="line">	return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>形参</code>表示<strong>函数的输入</strong></li>
<li>函数中的<code>执行语句</code> <strong>实现某一功能代码块</strong></li>
<li>函数可以有返回值，也可以没有，如果没有返回值，返回类型声明为void</li>
</ul>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><strong>需求</strong>：实际开发中<strong>需要在不同文件中调用其他文件中的函数</strong></p>
<p><strong>基本概念</strong></p>
<ul>
<li><p><code>头文件</code>是<strong>扩展名为h</strong>的文件，包含了<code>C函数声明</code>和<code>宏定义</code>，<strong>被多个源文件中引用共享</strong>。</p>
</li>
<li><p>头文件的类型的开发者<strong>自己编写的头文件</strong>和<strong>C标准库自带的头文件</strong></p>
</li>
<li><p>程序中要使用头文件，需要使用<code>C预处理指令#include</code>来引用。<code>stdio. h</code>头文件，是C标准库自带的头文件</p>
</li>
<li><p>文件包含命令(<code>#include</code>)，用来引入对应的头文件（h文件）。#include的<strong>处理过程</strong>是将<strong>头文件的内容插入到该命令所在的位置</strong>，使得<code>头文件</code>和<code>当前源文件</code><strong>连接成一个源文件</strong>，与复制粘贴的效果相同。直接在源文件中复制头文件的内容，容易出错，特别在程序是由多个源文件组成的时候。</p>
</li>
<li><p>所有的<code>常量</code>、<code>宏</code>、<code>系统全局变量</code>和<code>函数原型</code>写在<code>头文件</code>中，需要的时候随时再引用头文件</p>
</li>
</ul>
<p>​                                                                            <strong>工作原理图</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/08/400f7ef8cad9d26182ce82e0a80624f1.png" alt="image-20200708163738567"></p>
<ul>
<li>func.h头文件和func.c源文件<strong>名称一般相同</strong>为了使用</li>
</ul>
<p><strong>头文件的注意事项和细节说明</strong></p>
<ul>
<li><p><strong>引用头文件相当于复制头文件的内容，注意路径问题</strong></p>
</li>
<li><p>C语言中 include&lt;&gt;与 include””的区别include&lt;&gt; ：</p>
<ul>
<li><code>include&lt;&gt;</code>: 引用的是编译器的类库路径里面的头文件，用于<strong>引用系统头文件</strong></li>
<li><code>include””</code>：引用的是程序<strong>目录的相对路径中的头文件</strong>，</li>
<li>如果在<strong>程序目录</strong>没有找到引用的头文件则到<strong>编译器的类库路径</strong>的目录下找该头文件，</li>
<li>引用<strong>系统头文件</strong>，两种形式·都可以，include&lt;&gt;效率</li>
<li>引用<strong>用户头文件</strong>，只能使用 include””</li>
</ul>
</li>
<li><p>一个#include命令只能包含一个头文件，多个头文件需要多个# include命令</p>
</li>
<li><p>同一个头文件如果被多次引入，<strong>多次引入的效果和一次引入的效果相同</strong>，因为<strong>头文件在代码层面有防止重复引入的机制</strong></p>
</li>
<li><p>在一个被包含的文件.c中又可以包含另一个文件头文件.h</p>
</li>
<li><p>不管是<code>标准头文件</code>，还是<code>自定义头文件</code>，都<strong>只能包含变量和函数的声明</strong>，<strong>不能包含定义</strong>，否则在<strong>多次引入时会引起重复定义错误</strong></p>
</li>
</ul>
<h2 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h2><p>函数调用的规则适用于: <code>java</code>,<code>c++</code>，<code>php</code>等）</p>
<ul>
<li>当调用(执行)一个函数时，就会开辟一个独立的空间(栈)</li>
<li>每个栈空间是相互独立</li>
<li>当函数执行完毕后，会返回到调用函数位置，继续执行</li>
<li>函数有返回值，将返回值赋给接收的变量 当一个函数返回后，该函数对应的栈空间也就销毀</li>
</ul>
<h2 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h2><p><strong>一个函数在函数体内又调用了函数本身，称为递归调用</strong></p>
<ul>
<li><p>执行一个函数时，就创建一个新的受保护的独立空间（新函数栈）</p>
</li>
<li><p>函数的局部变量是独立的，不会相互影响</p>
</li>
<li><p>递归必须向退出递归的条件逼近，否则就是无限递归,造成栈溢出(StackOverFlow)</p>
</li>
<li><p>当一个函数执行完毕，或者遇到 return，就会返回，将结果返回给调用处</p>
</li>
</ul>
<p>🌰<strong>举例</strong></p>
<p>求出斐波那契数1,1,2,3,5,8,13.求整数n对应的斐波那契数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fbn</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n=<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fbn(n<span class="number">-1</span>)+ fbn(n<span class="number">-2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = fbn(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"res = %d"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个,以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时（还没吃），发现只有1个桃子了。求最初多少桃子？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peach</span><span class="params">(<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(day=<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (peach(day+<span class="number">1</span>)+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//分析过程</span></span><br><span class="line">	<span class="comment">//1.day=10有1个桃子</span></span><br><span class="line">	<span class="comment">//2.day=9有(day10+1)*2=（1+1）*2=4</span></span><br><span class="line">	<span class="comment">//3.day=8 (day9+1)*2=(4+1)*2=10</span></span><br><span class="line">	<span class="keyword">int</span> peachUm =  peach(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第一天有%d个桃子"</span>,peachUm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数的传递方式"><a href="#函数的传递方式" class="headerlink" title="函数的传递方式"></a>函数的传递方式</h2><p><strong>基本介绍</strong></p>
<ul>
<li>C语言传递参数可以是<code>值传递(pass by value)</code>，也可以<code>传递指针(a pointer passed by value)</code>也叫<strong>传递地址或者引用传递。</strong></li>
<li>不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，<strong>值传递的是值的拷贝</strong>，<strong>引用传递的是地址的拷贝</strong>，一般<strong>地址拷贝效率高</strong>，因为<strong>数据量小</strong>，而<strong>值拷贝决定拷贝的数据大小</strong>，<strong>数据越大</strong>，<strong>效率越低</strong>。</li>
</ul>
<p><strong>值传递和引用传递的使用特点</strong></p>
<ul>
<li><code>值传递</code>：变量直接存储值，内存通常在栈中分配</li>
<li>默认是<strong>值传递</strong>的数据类型有：1.基本数据类型2.结构体3.共用体4.枚举类型</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/08/96c8d59769dce374bb5b1da2d0e1aa0a.png" alt="image-20200708182517552"></p>
<ul>
<li><code>引用传递</code>:  变量存储的是一个地址，这个地址对应的空间才真正存储数据（值）。</li>
<li>默认是<strong>引用传递</strong>的数据类型有1.指针 2.数组</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/08/31e03c7aafe9dfd149b80a90482c1463.png" alt="image-20200708183714366"></p>
<ul>
<li>如果希望<strong>函数内的变量能修改函数外的变量</strong>，可以传入<strong>变量的地址&amp;</strong>，函数内<strong>以指针的方式操作变量</strong>（*指针从效果上看类似引用，修改结构体的属性。)</li>
</ul>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><ul>
<li>变量作用域(<code>Scope</code>),就是指<strong>变量的有效范围</strong></li>
<li>函数内部声明或定义的局部变量，作用域仅限于函数内部。</li>
<li>函数的<code>参数</code>，<code>形式参数</code>，被当作该<strong>函数内的局部变量</strong>，如果与<strong>全局变量同名它们会优先使用局部变量</strong>（编译器使用<strong>就近原则</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">20</span>;</span><br><span class="line">函数形参，会被视为n10的局部变量</span><br><span class="line">∥说明：当局部变量和全局变量同名时，以局部变量为准（就近原则</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"n=%d"</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main&#123;</span><br><span class="line">	func(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在所有<strong>函数外部定义的变量</strong>叫<strong>全局变量</strong>，<strong>作用域在整个程序有效</strong></li>
</ul>
<h3 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h3><ul>
<li><code>局部变量</code>，系统<strong>不会对其默认初始化</strong>，必须对局部变量初始化后才能使用，否则，程序运行后可能会异常退出。</li>
<li><code>全局变量</code>，系统会<strong>自动对其初始化</strong></li>
<li><strong>未初始化的的变量</strong>会在<strong>内存中存在一些垃圾值</strong></li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>‘\n’</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>pointer(指针)</td>
<td>NULL</td>
</tr>
</tbody></table>
<p><strong>作用域的注意事项和细节</strong></p>
<ul>
<li><p><code>全局变量（ Global Variable）</code>保存在<strong>内存的全局存储区</strong>中，占用<strong>静态的存储单元</strong>，它的<strong>作用域默认是整个程序</strong>，也就是所有的代码文件，包括源文件（c文件）和头文件（h文件）。</p>
<p>​                                                                  <strong>C程序内存布局图</strong></p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/09/97313603ab16527d1f40b9d59245a949.png" alt="image-20200709100907055"></p>
<ul>
<li><code>局部变量( local Variable)</code>保存在栈中，函数被调用时才动态地为变量分配存储单元，它的<strong>作用域仅限于函数内部</strong>。</li>
<li>C语言规定，<strong>只能从小的作用域向大的作用域中去寻找变量</strong>，而不能反过来</li>
<li><strong>同一个作用域，变量名不能重复</strong>，在不同的作用域，变量名可以重复，使用时编译器采用<strong>就近原则</strong></li>
<li><strong>{}包围的代码块也拥有独立的作用域</strong></li>
</ul>
<h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><p><code>static关键字</code>使用恰当能够大大<strong>提髙程序的模块化特性</strong>，<strong>有利于扩展和维护</strong></p>
<p>局部变量被static修饰后，我们称为<strong>静态局部变量</strong></p>
<ul>
<li><p>对应静态局部变量<strong>在声明时未赋初值</strong>，编译器也会把它<strong>初始化为0。</strong></p>
</li>
<li><p>静态局部变量存储于<strong>进程的静态存储区（全局性质）</strong>，<strong>只会被初始一次，即使函数返回，它的值也会保持不变</strong></p>
</li>
</ul>
<p><strong>全局变量使用 static修饰</strong></p>
<ul>
<li><strong>普通全局变量</strong>对整个工程可见，其他文件可以<strong>使用 extern外部声明后直接使用</strong>。其他文件不能再定义个与其相同名字的变量了（编译器会认为它们是同一个变量），<strong>静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响</strong></li>
<li><strong>不需要与其他文件共享的全局变量</strong>时，加上 <code>static关键字</code>能够有效地<strong>降低程序模块之间的耦合</strong>，避免不同文件同名变量的冲突，且不会误使用</li>
</ul>
<p><strong>函数使用static修饰</strong></p>
<ul>
<li><p>函数的使用方式与全局变量类似，<strong>函数的返回类型前加上 static</strong>，就是<code>静态函数</code></p>
</li>
<li><p><strong>非静态函数</strong>可以在另一个文件中<strong>通过 extern引用</strong></p>
</li>
<li><p><strong>静态函数</strong>只能在声明它的文件中可见，<strong>其他文件不能引用该函数</strong></p>
</li>
<li><p><strong>不同文件</strong>可以使用<strong>相同名字的静态函数，互不影响</strong></p>
</li>
</ul>
<h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>字符串函数</strong>的头文件<code>&lt;string.h&gt;</code></p>
<ul>
<li><p><strong>字符串的长度</strong>strlen()，从第一个字符开始直到空结束字符，但<strong>不包括空结束字符</strong></p>
</li>
<li><p><strong>拷贝字符串</strong>char * strcpy (char * dest, const char * src）*<em>把src所指向的字符串复制(原来的字符串会被覆盖)到dest *</em></p>
</li>
<li><p><strong>连接字符串</strong>char <em>strcat(char dest, const char <em>src）</em></em>把src所指向的字符串追加到dest所指向的字符串的结尾**</p>
</li>
</ul>
<h3 id="时间和日期相关函数"><a href="#时间和日期相关函数" class="headerlink" title="时间和日期相关函数"></a>时间和日期相关函数</h3><p>头文件<code>&lt;time.h&gt;</code></p>
<ul>
<li><strong>获取当前时间</strong>char * ctime(const time_t * timer) <strong>返回</strong>一个表示<strong>当地时间的字符串</strong>，当地时间是<strong>基于参数 timer</strong></li>
</ul>
<p>🌰<strong>举例</strong></p>
<p><strong>计算函数的执行时间</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20771119</span>;i++)&#123;</span><br><span class="line">    	sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt; <span class="number">10</span>;j++)&#123;</span><br><span class="line">    		sum +=j;</span><br><span class="line">   		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//time_t 是结构体类型</span></span><br><span class="line">    <span class="keyword">time_t</span> curtime;</span><br><span class="line">    <span class="comment">//time()完成初始化</span></span><br><span class="line">    time(&amp;curtime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前时间=%s"</span>,ctime(&amp;curtime));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先得到执行test前的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> <span class="keyword">start_t</span>,<span class="keyword">end_t</span>;</span><br><span class="line">    <span class="comment">//时间差</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">diff_t</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"程序启动 \n"</span>);</span><br><span class="line">    <span class="comment">//初始化得到当前时间</span></span><br><span class="line">    time(&amp;<span class="keyword">start_t</span>);</span><br><span class="line">    <span class="comment">//执行test()</span></span><br><span class="line">    test();</span><br><span class="line">	<span class="comment">//得到执行test后的时间</span></span><br><span class="line">    time(&amp;<span class="keyword">end_t</span>);</span><br><span class="line">    <span class="comment">//时间差 秒</span></span><br><span class="line">    <span class="keyword">diff_t</span> = difftime(<span class="keyword">end_t</span>,<span class="keyword">start_t</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行test()函数耗用了%2f秒"</span>,<span class="keyword">diff_t</span>); 	getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数学相关函数"><a href="#数学相关函数" class="headerlink" title="数学相关函数"></a>数学相关函数</h3><p>头文件<code>&lt;math.h&gt;</code> 定义了各种数学函数和一个宏。库中所有<strong>可用的功能</strong>都带有<strong>一个 double类型的参数且都返回 double类型的结果</strong></p>
<ul>
<li>double exp (double x）<br>返回e的<strong>x次幂</strong>的值</li>
<li>double log (double x)<br>返回x的<strong>自然对数</strong>（基数为e的对数）</li>
<li>double pow (double x, double y)<br>返回<strong>x的y次幂。</strong></li>
<li>double sqrt(double x)<br>返回<strong>x的平方根</strong>。</li>
<li>double fabs(double x)<br>返回<strong>x的绝对值</strong>。</li>
</ul>
<h3 id="基本数据类型和字符串函数转换"><a href="#基本数据类型和字符串函数转换" class="headerlink" title="基本数据类型和字符串函数转换"></a>基本数据类型和字符串函数转换</h3><p><strong>sprintf()函数的使用</strong></p>
<ul>
<li><code>sprintf()函数</code>与<code>printf()函数</code>的功能相似。 sprintf函数<strong>打印到字符串中</strong>，而 printf函数打印输<strong>出到屏幕上</strong>。 sprintf函数<strong>可以完成其他数据类型转换成字符串类型</strong>的操作</li>
<li>该函数包含在 <code>&lt;stdio.h&gt;</code>的头文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> strl[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2077</span>,b=<span class="number">1024</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">2077.1119</span>;</span><br><span class="line">    <span class="comment">//1. sprintf是一个系统函数,将结果存放到字符串中</span></span><br><span class="line">    <span class="comment">//2.格式化的结果，会存放到str1中</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str1,<span class="string">" %d %d"</span>,a,b); </span><br><span class="line">    <span class="built_in">sprintf</span>(str2,<span class="string">"%.2f"</span>,d); </span><br><span class="line"><span class="comment">//%8.2f含义是格式化后，一共有8位，小数点后占用2位，小数点前用空格占位</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str3,<span class="string">"%8.2f"</span>,d);</span><br><span class="line">    <span class="built_in">printf</span>（<span class="string">"strl=%s str=%os str3=%s"</span>,strl,str2,str3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>字符串类型转换为基本数据类型</strong></p>
<p>通过<code>&lt;stdlib.h&gt;</code>的函数调用 <strong>atoi() ,atof()</strong>即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">10</span>]=<span class="string">"123456"</span>;</span><br><span class="line">        <span class="keyword">char</span> str2[<span class="number">10</span>]=<span class="string">"12.67423"</span>;</span><br><span class="line">        <span class="keyword">char</span> str3[<span class="number">10</span>]=<span class="string">"cyberpunk”；    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        //1.atoi(str) 将str转成整数</span></span><br><span class="line"><span class="string">        int numl = atoi(str);</span></span><br><span class="line"><span class="string">        //2.atof(st2)将st2转成小数</span></span><br><span class="line"><span class="string">        double d = atof(str2);</span></span><br><span class="line"><span class="string">        //3.截取字符数组的第一个字符</span></span><br><span class="line"><span class="string">        str[0];</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将字符数组转成基本数据类型时，要确保能够转成有效的数据，“123” =&gt; 123 ，但 “cyberpunk” =&gt; 不能转化整型</li>
<li>格式错误,会默认转成0或者0.00</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=91" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/posts/ebce/</url>
    <content><![CDATA[<h3 id="位运算符以及源码-反码-补码"><a href="#位运算符以及源码-反码-补码" class="headerlink" title="位运算符以及源码,反码,补码"></a>位运算符以及源码,反码,补码</h3><ul>
<li>二进制的最高位是符号位:0表示正数,1表示负数</li>
<li>正数三码合一,均相同</li>
<li><strong>负数</strong>的反码 = 符号位不变,其他位取反(0=&gt;1,1=&gt;0)</li>
<li><strong>负数</strong>的补码 = 反码 + 1</li>
<li>0的补码,原码都是0,+0的反码 = 0000 0000,-0的补码 = 1111 1111;</li>
<li><strong>计算机运算</strong>的时候都是以<strong>补码</strong>的方式来运行 原因:可以将正负数统一起来</li>
</ul>
<table>
<thead>
<tr>
<th>运算规则</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;:按位与</td>
<td>相同为1,否则为0</td>
</tr>
<tr>
<td>|:按位或</td>
<td>有1为1,否则为0</td>
</tr>
<tr>
<td>^:按位异或</td>
<td>不同为1,否则为0</td>
</tr>
<tr>
<td>~:按位取反</td>
<td>1转换为0,0转换为1</td>
</tr>
</tbody></table>
<p>🌰​举两个例子</p>
<p><strong>~2:对2取反</strong></p>
<ul>
<li>1.2是正数三码合一得到补码:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#int占4个字节 1个字节等于8位</span><br><span class="line">补码: 00000000 00000000 00000000 00000010</span><br><span class="line">#进行取反</span><br><span class="line">补码: 11111111 11111111 11111111 11111101</span><br><span class="line">#将取反后得到的补码(11111111 11111111 11111111 11111101)转成源码</span><br><span class="line">#负数的补码 &#x3D; 反码 + 1</span><br><span class="line">反码: 补码 - 1 &#x3D; 11111111 11111111 11111111 11111100</span><br><span class="line">#负数的反码 &#x3D; 符号位不变,其他位取反(0&#x3D;&gt;1,1&#x3D;&gt;0)</span><br><span class="line">源码: 10000000 00000000 00000000 00000011</span><br><span class="line">#对2取反的结果是-3</span><br><span class="line">~2 &#x3D;&gt; -3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = ~<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/25/66509c6ebf73a738a3e86da02d1cab4f.png" alt="image-20200625172956190"></p>
<p><strong>2&amp;-3:2对-3进行按位与运算</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取2的补码</span><br><span class="line">补码: 00000000 00000000 00000000 00000010</span><br><span class="line">#获取-3的源码</span><br><span class="line">源码: 10000000 00000000 00000000 00000011</span><br><span class="line">#负数的反码 &#x3D; 符号位不变,其他位取反(0&#x3D;&gt;1,1&#x3D;&gt;0)</span><br><span class="line">反码: 11111111 11111111 11111111 11111100</span><br><span class="line">#获取-3的补码</span><br><span class="line">#负数的补码 &#x3D; 反码 + 1</span><br><span class="line">补码: 11111111 11111111 11111111 11111101</span><br><span class="line"></span><br><span class="line">#将2和-3的补码进行运算</span><br><span class="line"> 2的补码: 00000000 00000000 00000000 00000010</span><br><span class="line">-3的补码: 11111111 11111111 11111111 11111101</span><br><span class="line">&amp;: 相同为1,否则为0</span><br><span class="line">#运算结果 为0</span><br><span class="line">00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码如下:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span> &amp; <span class="number">-3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b = %d"</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/25/8739d86e6f646cbbc0daa0318c2a2dfb.png" alt="image-20200625175424053"></p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p><strong>算术左移&lt;&lt;:</strong> <strong>符号位不变,低位补0</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 &lt;&lt; 2，则是将数字3左移2位</span><br><span class="line">#首先把3转换为二进制数字</span><br><span class="line">00000000 00000000 00000000 00000011</span><br><span class="line">#把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零</span><br><span class="line">#转换为十进制是12</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码如下:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d"</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/25/ae4bc9b8187b6a5973852f953ff48973.png" alt="image-20200625200949845"></p>
<p><strong>算术右移&gt;&gt;</strong>: <strong>低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 &gt;&gt; 2，则是将数字11右移2位</span><br><span class="line">#首先把11转换为二进制数字</span><br><span class="line">00000000 00000000 00000000 00001011</span><br><span class="line">#把低位的最后两个数字移出，因为该数字是正数，所以在高位补零</span><br><span class="line">#转换为十进制是2</span><br><span class="line">00000000 00000000 00000000 00000010</span><br><span class="line"></span><br><span class="line">-1 &gt;&gt; 2</span><br><span class="line">#获取-1的源码</span><br><span class="line">10000000 00000000 00000000 00000001</span><br><span class="line">#源码&#x3D;&gt;反码</span><br><span class="line">11111111 11111111 11111111 11111110</span><br><span class="line">#反码&#x3D;&gt;补码</span><br><span class="line">11111111 11111111 11111111 11111111</span><br><span class="line">#移动两位后 (补码)</span><br><span class="line">11111111 11111111 11111111 11111111</span><br><span class="line">#补码&#x3D;&gt;源码</span><br><span class="line">#转换为十进制是-1</span><br><span class="line">10000000 00000000 00000000 00000001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码如下:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">11</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">-1</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d = %d e = %d"</span>,d,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/25/3499348d49718a15382fb71f28120f1d.png" alt="image-20200625201030080"></p>
<ul>
<li><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2></li>
</ul>
<div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=57" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
<a class="btn-beautify button--animated outline green larger" href="https://baike.so.com/doc/23743705-24299622.html" target="_blank" rel="noopener" title="360百科"><i class="far fa-hand-point-right fa-fw"></i> 360百科 </a>
</div>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>计算机基础知识</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/posts/9f93/</url>
    <content><![CDATA[<h2 id="指针的基本介绍"><a href="#指针的基本介绍" class="headerlink" title="指针的基本介绍"></a>指针的基本介绍</h2><ul>
<li><code>指针</code>是内存的地址；所谓指针变量，也就是保存了内存地址的变量。</li>
<li><strong>获取变量的地址用&amp;</strong>，比如：int num=10，获取num的地址：&amp;num <strong>获取指针本身的地址不加取值符号</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr本身的地址=%p ptr存放的地址=%p ptr指向的值"</span>,&amp;ptr,ptr,*ptr);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>指针类型，指针变量存的是一个地址</strong>，这个地址指向的空间存的才是值比如：int  * ptr = &amp;num；<strong>ptr就是指向int类型的指针变量，ptr是int*类型</strong>。</p>
</li>
<li><p><strong>获取指针类型所指向的值</strong>，<strong>使用:*  (取值符号)</strong>，比如：int * ptr，<strong>使用*ptr获取ptr指向的值</strong></p>
</li>
<li><p>使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*整型的指针*/</span></span><br><span class="line"><span class="keyword">int</span> *ip; </span><br><span class="line"><span class="comment">/*double型的指针*/</span> </span><br><span class="line"><span class="keyword">double</span> *dp;</span><br><span class="line"><span class="comment">/*浮点型的指针*/</span></span><br><span class="line"><span class="keyword">float</span> *fp;</span><br><span class="line"><span class="comment">/*字符型的指针*/</span></span><br><span class="line"><span class="keyword">char</span> *ch;</span><br></pre></td></tr></table></figure>

<p><strong>🌰举例内存图解</strong> </p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/14/cc880e41e8897b36380d87d0fffcc3fe.png" alt="31e03c7aafe9dfd149b80a90482c1463"></p>
<p><strong>指针可执行算术运算</strong>。四种算术运算：<code>++,- - ,+, -</code>,</p>
<p><strong>指针递增(++)操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX =<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var[] =&#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i,*ptr;</span><br><span class="line">	ptr = var;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MAX;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"var[%d] 地址=%p\n"</span>,i,ptr);</span><br><span class="line">        <span class="comment">//ptr=ptr+1（1个int字节数;ptr存放值+4字节(int)</span></span><br><span class="line">        <span class="built_in">print</span>（<span class="string">"存储值: var[%d =%dn"</span>,i,*ptr); 			</span><br><span class="line">        ptr++;</span><br><span class="line">	&#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存图解</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/14/f697f699d6db795ad5123dc4700e823b.png" alt="image-20200714171833898"></p>
<ul>
<li><strong>数组</strong>在内存中是<strong>连续分布</strong>的</li>
<li>当对指针进行++时，指针会按照它<strong>指向的数据类型字节数大小增加</strong>，比如i<code>int*指针</code>，每++，<strong>增加4个字节</strong></li>
</ul>
<p><strong>指针(-)操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var[] =&#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i,*ptr;</span><br><span class="line">	ptr = var;</span><br><span class="line">    <span class="comment">//ptr=ptr-1（1个int字节数;ptr存放值-4字节(int)</span></span><br><span class="line">	ptr -=<span class="number">1</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"var[1]= %d 地址=%p ptr存储的地址=%p ptr指向的值=%d"</span>,var[<span class="number">1</span>],&amp;var[<span class="number">1</span>],ptr,*ptr);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以对指针按照指定的字节数大小进行+或者-的操作，可以快速定位想要的地址</strong></p>
<h2 id="指针的比较"><a href="#指针的比较" class="headerlink" title="指针的比较"></a>指针的比较</h2><p><code>指针</code>可以用<strong>关系运算符进行比较</strong>，如果p1和p2指向两个变量，比如同一个数组中的不同元素，则可对pl和p2进行大小比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var[] =&#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i,*ptr;</span><br><span class="line">	ptr = var;</span><br><span class="line">    <span class="keyword">if</span>(ptr==&amp;var[<span class="number">0</span>])&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"cyberpunk2077"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr==var)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"cyberpunk2077"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr&lt;=&amp;var[<span class="number">1</span>])&#123;</span><br><span class="line">       <span class="comment">//可以比较,返回true </span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"cyberpunk2077"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>%x 和 %p的比较 <code>%x</code> 输出结果会<strong>去掉地址前面的0</strong> ， <code>%p</code>输出结果<strong>保留地址前面的0</strong> </li>
</ul>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p><strong>基本介绍</strong></p>
<p><strong>让数组的元素指向int或其他数据类型的地址（指针）</strong>。可以使用<code>指针数组</code></p>
<p><strong>指针数组定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 * 指针数组名 [大小];</span><br><span class="line"><span class="keyword">int</span>*ptr[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>ptr声明为一个指针数组</li>
<li>由<strong>3个整数指针</strong>组成。ptr中的<strong>每个元素</strong>，<strong>都是一个指向int值的指针</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX =<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var[] =&#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i,*ptr[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MAX;i++)&#123;</span><br><span class="line">       <span class="comment">//赋值为整数的地址</span></span><br><span class="line">       ptr[i] = &amp;var[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MAX;i++)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"var[%d]=%d ptr[%d]本身的地址=%p\n"</span>,i,*ptr[i],i,&amp;ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/14/fe7253f1d54a11604f17415e8e994aa0.png" alt="image-20200714181338508"></p>
<h2 id="多重指针"><a href="#多重指针" class="headerlink" title="多重指针"></a>多重指针</h2><p><strong>基本介绍</strong></p>
<p><code>指向指针的指针</code>是一种<strong>多级间接寻址</strong>的形式，或者说是一个<code>指针链</code>。定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> var[] =&#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i,*ptr;</span><br><span class="line">    <span class="comment">//var变量的值赋给ptr1</span></span><br><span class="line">    ptr1 = &amp;var;</span><br><span class="line">    <span class="comment">//ptr1存放的地址赋给ptr2</span></span><br><span class="line">    ptr2 = &amp;ptr1;</span><br><span class="line">    <span class="comment">//ptr2存放的地址赋给ptr3</span></span><br><span class="line">    ptr3 = &amp;ptr3;</span><br><span class="line">    <span class="comment">//var代表数组的首地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"var[0]=%p var[0]=%d\n"</span>,&amp;var,var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ptr1本身的地址=%p ptr1存放的地址=%p *ptr1=%d\n"</span>,&amp;ptr1,ptr1,*ptr1);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"ptr2本身的地址=%p ptr2存放的地址=%p *ptr1=%d\n"</span>,&amp;ptr2,ptr2,*ptr2);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"ptr3本身的地址=%p ptr3存放的地址=%p *ptr1=%d\n"</span>,&amp;ptr3,ptr3,*ptr3);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/14/84c0f449534bd9e788d2e97573fa56cd.png" alt="image-20200714182508266"></p>
<p><strong>传递指针给函数</strong></p>
<p>当函数的形参类型是<code>指针类型</code>时，是使用该函数时，需要<code>传递指针</code>，或者<code>地址</code>，或者<code>数组</code>(数组名代表该数组首地址)给该<strong>形参</strong>，</p>
<h2 id="指针函数-返回指针的函数"><a href="#指针函数-返回指针的函数" class="headerlink" title="指针函数(返回指针的函数)"></a>指针函数(返回指针的函数)</h2><p><strong>定义</strong>：返回指针的函数C语言<strong>允许函数的返回值是一个指针</strong>(地址)</p>
<p><strong>🌰举例</strong></p>
<p><strong>比较字符串长度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数返回的char*（指针）</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strlong</span><span class="params">(<span class="keyword">char</span>*str1,<span class="keyword">char</span>*str2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strl的长度%d str2的长度%d \n"</span>,<span class="built_in">strlen</span>(str1),<span class="built_in">strlen</span>(str2));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(str1)&gt;=<span class="built_in">strlen</span>(str2))&#123;</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">20</span>],str2[<span class="number">20</span>],*str;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入第一字符串:\n"</span>);</span><br><span class="line">    gets(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入第二字符串:\n"</span>);</span><br><span class="line">    gets(str2);</span><br><span class="line">    str = strlong(str1,str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s的字符串中较长"</span>,str);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项和细节</strong></p>
<ul>
<li>函数<strong>运行结束</strong>后会<strong>销毁在它内部定义的所有局部数据</strong>，包括<code>局部变量</code>、<code>局部数组</code>和<code>形式参数</code>，函数返回的指针不能指向这些数据</li>
<li>销毁并<strong>不是将局部数据所占用的内存全部清零</strong>，而是<strong>程序放弃对它的使用权限</strong>，后面的代码可以使用这块内存</li>
<li>C语言<strong>不支持在调用函数时返回局部变量的地址</strong>，如果确实有这样的需求，<strong>需要定义局部变量为 static变量</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>*<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int n=100;局部变量，在func返回时，就会销毁	</span></span><br><span class="line">    <span class="comment">//如果这个局部变量是 static性质的，那么n存放数据的空间在静态数据区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回指针</span></span><br><span class="line">    <span class="keyword">int</span>*p= func();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//可能会使用到局部变量int n=100 内存空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cyberpunk2077\n"</span>);</span><br><span class="line">    <span class="comment">//当int n=100;在内存中开辟空间未被使用时,可以输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value=%d\n"</span>,n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数指针-指向函数的指针"><a href="#函数指针-指向函数的指针" class="headerlink" title="函数指针(指向函数的指针)"></a>函数指针(指向函数的指针)</h2><p><strong>基本介绍</strong></p>
<ul>
<li><p>一个函数总是<strong>占用一段连续的内存区域</strong>，函数名在<strong>表达式</strong>中有时也会<strong>被转换为该函数所在内存区域的首地址</strong>，这和数组名非常类似</p>
</li>
<li><p>把函数的这个首地址(或称入口地址)<strong>赋予一个指针变量</strong>，使指针变量指向函数所在的内存区域，然后<strong>通过指针变量就可以找到并调用该函数</strong>。这种指针就是<code>函数指针</code>。</p>
</li>
</ul>
<p><strong>函数指针定义</strong></p>
<p><strong>returnType(*pointerName)(param list)</strong></p>
<ul>
<li><code>returnType</code>为函数指针<strong>指向的函数返回值类型</strong></li>
<li><code>pointerName</code>为<strong>函数指针名称</strong></li>
<li><code>param list</code>为函数指针<strong>指向的函数的参数列表</strong></li>
<li><code>参数列表</code>中<strong>可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称</strong></li>
<li><strong>注意()的优先级高于*，第一个括号不能省略</strong>，如果写作 <code>returnType * pointerName(param list)</code>；就成了<strong>函数原型</strong>，<strong>表明函数的返回值类型为 return Type*</strong></li>
</ul>
<p><strong>🌰举例</strong> </p>
<p><strong>用函数指针来实现对函数的调用，返回两个整数中的最大值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,maxVal;</span><br><span class="line">    <span class="comment">//函数指针的名字 pmax</span></span><br><span class="line">    <span class="comment">//int表示该函数指针指向的函数是返回int类型</span></span><br><span class="line">    <span class="comment">//(int,int)表示该函数指针指向的函数形参是接收两个int</span></span><br><span class="line">    <span class="comment">//在定义函数指针时，也可以写上形参名int(*pmax)</span></span><br><span class="line">    <span class="keyword">int</span>(*pmax)(<span class="keyword">int</span>,<span class="keyword">int</span>) = <span class="built_in">max</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input two numbers:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="comment">//(*pmax)(x,y)通过函数指针去调用函数max</span></span><br><span class="line">    maxVal = (*pmax)(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Max value:%d pmax=%p pmax本身的地址=%p\n"</span>,maxVal,pmax,&amp;pmax);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200715122648.png" alt="image-20200715122611182"></p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p><strong>基本介绍</strong></p>
<p><code>函数指针变量</code>可以<strong>作为某个函数的参数</strong>来使用的，<code>回调函数</code>就是一个<strong>通过函数指针调用的函数</strong>,回调函数是由其他函数执行时调用当前传入的函数(通过函数指针完成）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//回调函数int(*f)(void)</span></span><br><span class="line"><span class="comment">//f就是函数指针，它可以接收的函数是(返回int，没有形参的函数）</span></span><br><span class="line"><span class="comment">//f在这里被inteRray调用,充当了回调函数角色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initArray</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> arraySize,<span class="keyword">int</span> (*f)(<span class="keyword">void</span>))</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arraySize;i++)&#123;</span><br><span class="line">        <span class="comment">//通过函数指针调用了 getNextRandomValue函数</span></span><br><span class="line">        <span class="built_in">array</span>[i] = f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取随机数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextRandomValue</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>],i;</span><br><span class="line">    <span class="comment">//调用initArray函数</span></span><br><span class="line">    initArray(<span class="built_in">array</span>,<span class="number">10</span>,getNextRandomValue);</span><br><span class="line">    <span class="comment">//输出赋值后的数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针的注意事项和细节</strong></p>
<ul>
<li><code>指针</code>变量存放的是<strong>地址</strong>，指针的本质就是地址。</li>
<li><strong>变量声明</strong>的时候，如果<strong>没有确切的地址赋值，为指针变量赋一个NULL值</strong></li>
<li><strong>赋为NULL值的指针</strong>被称为<code>空指针</code>，NULL指针是一个定义在标准库<code>&lt; stdio.h&gt;</code>中的<strong>值为零的常量</strong>#define NULL 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>*p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p><strong>不同数据在内存中分配说明：</strong></p>
<ul>
<li><code>全局变量</code>——&gt;内存中的<strong>静态存储区</strong></li>
<li><code>非静态的局部变量</code>一一&gt;内存中的<strong>动态存储区</strong>—&gt;<code>stack栈</code></li>
<li><strong>临时使用的数据</strong>-建立<strong>动态内存分配区域</strong>，<strong>需要时随时开辟，不需要时及时释放</strong>——&gt;<code>heap堆</code></li>
<li>根据需要向系统申请所需大小的空间，由于<strong>未在声明部分定义其为变量或者数组</strong>，<strong>不能通过变量名或者数组名来引用这些数据，只能通过指针来引用</strong></li>
</ul>
<p><strong>内存动态分配的相关函数</strong></p>
<p>头文件<code>&lt;stdlib.h&gt;</code>声明了<strong>四个关于内存动态分配的函数</strong></p>
<p>1.函数原型<code>void* malloc(usigned int size)</code>memory allocation(内存分配)</p>
<ul>
<li><strong>作用</strong>:在内存的<code>动态存储区(堆区)</code>中分配一个<strong>长度为size的连续空间。</strong></li>
<li>形参<code>size</code>的类型为<strong>无符号整型</strong>，<strong>函数返回值是所分配区域的第一个字节的地址</strong>，即此函数是一个<code>指针型函数</code>，返回的指针指向该分配域的开头位置。</li>
<li>malloc(100)；<strong>开辟100字节的临时空间，返回值为其第一个字节的地址</strong></li>
</ul>
<p>2.函数原型<code>void* calloc(unsigned n, unsigned size)</code></p>
<ul>
<li><strong>作用</strong>:在内存的<code>动态存储区中</code>分配n个<strong>长度为size的连续空间，这个空间一般比较大，足以保存一个数组</strong></li>
<li><code>calloc函数</code>可以为<strong>一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size</strong></li>
<li>函数<strong>返回指向所分配域的起始位置的指针</strong>；分配<strong>不成功，返回NULL</strong></li>
<li>p=calloc(50,4)；开辟50<em>4个字节临时空间，把*</em>起始地址分配给指针变量p**</li>
</ul>
<p>3.函数原型：<code>void free(void*p)</code></p>
<ul>
<li><p><strong>作用</strong>:<strong>释放变量p所指向的动态空间</strong>，<strong>放弃空间的使用权限不是销毁内存</strong>使这部分空间<strong>能重新被其他变量使用</strong></p>
</li>
<li><p>p是<strong>最近一次调用</strong><code>calloc</code>或 <code>malloc</code>函数时的<strong>函数返回值</strong></p>
</li>
<li><p>free函数<strong>无返回值</strong></p>
</li>
<li><p>free(p)  <strong>释放p所指向的已分配的动态空间</strong></p>
</li>
</ul>
<p>4.函数原型<code>void* realloc(void*p,unsigned int size)</code></p>
<ul>
<li><strong>作用</strong>:<strong>重新分配 <code>malloc</code>或<code>calloc</code>函数获得的动态空间大小</strong>，将p指向的<strong>动态空间大小改变为size</strong>,p的<strong>值不变</strong>，分<strong>配失败返回NULL</strong> </li>
<li>realloc(p,50)  将p所指向的<strong>已分配的动态空间改为50字节</strong></li>
</ul>
<p><strong>返回类型说明</strong></p>
<p><code>C99标准</code>把以上 <code>malloc</code>, <code>calloc</code>, <code>realloc</code>函数的<strong>基类型定为void类型</strong>，这种指针称为<strong>无类型指针(typeless pointer)</strong>，即<strong>不指向哪一种具体的类型数据</strong>，只表示用来<strong>指向一个抽象的类型的数据</strong>，即仅<strong>提供一个纯地址</strong>，而<strong>不能指向任何具体的对象</strong>。<br><code>C99</code>允许使用<strong>基类型为void的指针类型</strong>。可以定义一个基类型为void的指针变量(即void<em>型变量），它不指向任何类型的数据。把*</em>“指向void类型“”理解为“指向空类型”或“不指向确定的类型”的数据<strong>。在将它的值赋给另一指针变量时由</strong>系统对它进行类型转换<strong>，使之适</strong>合于被赋值的变量的类型**。</p>
<p><strong>🌰举例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p3为无类型指针变量（基类型为void型）</span></span><br><span class="line"><span class="keyword">void</span> * p3；</span><br><span class="line"><span class="comment">//将p1的值转换为void*类型，然后赋值给p3</span></span><br><span class="line">p3=(<span class="keyword">void</span> *)pl;</span><br><span class="line"><span class="comment">//将p3的值转换为char*类型，然后赋值给p2</span></span><br><span class="line">p2=(<span class="keyword">char</span>*)p3；</span><br><span class="line"><span class="comment">//赋值后p3得到a的纯地址，但并不指向a，不能通过*p3输出</span></span><br><span class="line">p3=&amp;a;  √ 纯地址</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p3); ×</span><br></pre></td></tr></table></figure>

<p><strong>动态分配内存的基本原则</strong></p>
<ul>
<li><strong>避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大</strong></li>
<li><strong>在需要时分配内存</strong>。只要<strong>使用完堆上的内存块，及时释放它(</strong>如果使用<strong>动态分配内存</strong>，需要遵守原则：<strong>谁分配，谁释放</strong>)，否则可能出现<code>内存泄漏</code></li>
<li>分配后一定要释放内存</li>
<li><strong>释放内存之前，确保不会无意中覆盖堆上已分配的内存地址</strong>，否则程序就会出现<code>内存泄漏</code>。<strong>注意循环中分配内存</strong></li>
</ul>
<p><strong>指针使用一览</strong></p>
<table>
<thead>
<tr>
<th>变量定义</th>
<th>类型表示</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>int * p</td>
<td>int *</td>
<td>定义p为指向整型数据的指针变量</td>
</tr>
<tr>
<td>int * p[4]</td>
<td>int *</td>
<td>定义指针数组p,它由4个指向整型数据的指针元素组成</td>
</tr>
<tr>
<td>int (* p)[4]</td>
<td>int(*)[4]</td>
<td>p为指向包含4个元素的一维数组的指针变量</td>
</tr>
<tr>
<td>int * p()</td>
<td>int * ()</td>
<td>p为返回一个指针的函数，该指针指向整型数据</td>
</tr>
<tr>
<td>int (* p)()</td>
<td>int (*)()</td>
<td>p为指向函数的指针，该函数返回一个整型值</td>
</tr>
<tr>
<td>int ** p</td>
<td>int **</td>
<td>p是一个指针变量，它指向一个指向整型数据的指针变量</td>
</tr>
<tr>
<td>void * p</td>
<td>void *</td>
<td>p是一个指针变量，基类型为void(空类型),不指向具体的对象</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=133" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型运算及表达式</title>
    <url>/posts/eddf/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的基本概念"><a href="#变量的基本概念" class="headerlink" title="变量的基本概念"></a>变量的基本概念</h3><p><strong>定义</strong>：<strong>程序的基本组成单位</strong>,相当于内存中一个数据<strong>存储空间</strong>的表示，可以把变量看做房间的门牌号，通过门牌号找到房间，通过变量名可以访问到变量（值）。</p>
<ul>
<li>声明变量int num;</li>
<li>赋值num = 2077</li>
<li>使用printf（”num=%”， num）</li>
<li>一步到位：int num =2077</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//整型</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//小数</span></span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">2.3</span>;</span><br><span class="line">    <span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'A'</span>;</span><br><span class="line">    <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">"尚硅谷"</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     说明</span></span><br><span class="line"><span class="comment">     1.如果输出的整数%d</span></span><br><span class="line"><span class="comment">     2.如果输出的是小数%f,保留小数点%2f</span></span><br><span class="line"><span class="comment">     3.如果输出的是字符%c</span></span><br><span class="line"><span class="comment">     4.如果输出的是字符串%s</span></span><br><span class="line"><span class="comment">     5.在输出不同数据时,对应的格式化的形式要对应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"num = %d sorce = %.2f gender = %c name = %s"</span>,num, score, gender, name);</span><br><span class="line">     getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量使用注意事项</strong></p>
<ul>
<li>变量表示内存中的一个存储区域（不同的数据类型，占用的空间大小不一样）</li>
<li>该区域有自己的名称和类型</li>
<li>变量必须先声明，后使用</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量在同一个作用域内不能重名</li>
<li>变量三要素（变量名+值+数据类型)</li>
</ul>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>每一种数据都定义了明确的<code>数据类型</code>，在<strong>内存</strong>中分配了不同大小的内存空间（使用字节表示）。</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200705093019.png" alt="image-20200705093009992"></p>
<ul>
<li>在c中，没有字符串类型，使用字符数组表示字符串</li>
<li>在不同系统上，部分数据类型字节长度不一样，int2或者4</li>
</ul>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>C语言的<code>整数类型</code>就是用于存放<code>整数</code>值的，比如2020,2077</p>
<p>​                                                                    <strong>整型的分类</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1字节</td>
<td>-128即-(2^7)到127 (2^7-1）</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1字节</td>
<td>0到255(2^8-1)</td>
</tr>
<tr>
<td>signed char</td>
<td>1字节</td>
<td>-128即-(2^7)到127 (2^7-1）</td>
</tr>
<tr>
<td>int /signed int</td>
<td>2或4字节</td>
<td>-32768 -(2^15）到  32768 (2 ^ 15 - 1) 或-2147483648  (2 ^ 31）到2147483647(2^31-1)</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2字节</td>
<td>0到65535（2 ^16-1）或0到4294967295（2 ^ 32-1）</td>
</tr>
<tr>
<td>short / signed short</td>
<td>2字节</td>
<td>-32768 -(2^15) 到32767（2 ^15-1）</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2字节</td>
<td>0到65535（2 ^ 16-1）</td>
</tr>
<tr>
<td>long / signed long</td>
<td>4字节</td>
<td>-2147483648（2 ^ 31）到2147483647（2^31-1)</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4字节</td>
<td>0  到 4294967295（2^32 -1）</td>
</tr>
</tbody></table>
<p>各种类型的存储大小与<strong>操作系统</strong>、<strong>系统位数</strong>和<strong>编译器</strong>有关，目前通用的以<strong>64位系统</strong>为主。</p>
<ul>
<li>C语言的整型类型，分为有符号 signed和无符号 unsigned两种，默认是 signed</li>
<li>C程序中整型常声明为int型，除非不足以表示大数，才使用 long long</li>
<li>bit（位）计算机中的最小存储单位。byte（字节）计算机中<strong>基本存储单元1byte=8bit</strong> <ul>
<li>short在内存中占有2字节</li>
<li>int在内存中占有4个字节</li>
</ul>
</li>
</ul>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>C语言的<strong>浮点类型</strong>可以表示一个<strong>小数</strong>，比如2020.4，2020.9，2020.11</p>
<p>​                                                                      <strong>浮点类型的分类</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>float 单精度</td>
<td>4个字节</td>
<td>1.2 * 10 ^ -38 到 3.4 * 10 ^ 38</td>
<td>6位小数</td>
</tr>
<tr>
<td>double 双精度</td>
<td>8个字节</td>
<td>2.3 * 10 ^ -308 到 1.7 * 10 ^ 308</td>
<td>15位小数</td>
</tr>
</tbody></table>
<ul>
<li>浮点数在机器中存放形式的简单说明，浮点数=符号位+指数位+尾数位，浮点数是近似值</li>
<li>尾数部分可能丢失，造成精度损失</li>
<li>浮点型常量默认为 double型，声明float型常量时，须后加‘f’或‘F’。</li>
<li>浮点型常量有两种表示形式</li>
</ul>
<p><strong>十进制数形式</strong>：如：512.0f     .512<br><strong>科学计数法形式</strong>：如：5.12e2、5.12E-2</p>
<ul>
<li>通常情况下，应该使用 double型，因为它比 float型更精确。</li>
<li>输出时，默认保留小数点6位</li>
</ul>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>字符类型可以表示<strong>单个字符</strong>，字符类型是<code>char</code>,char是<strong>1个字节</strong>（可以存字母或者数字），</p>
<p><strong>多个字符称为字符串</strong>，在C语言中使用<strong>char数组</strong>表示，数<strong>组不是基本数据类型，而是构造类型</strong></p>
<ul>
<li>字符常量是用单引号（”）括起来的单个字符。例如：char c1= ‘a’； char c3 = ‘2’）</li>
<li>C语言中允许使用<strong>转义字符‘\’</strong> 来将其后的字符转变为<strong>特殊字符型常量</strong>。</li>
</ul>
<p>🌰<strong>举例</strong></p>
<ul>
<li>例如：char c3 = ‘\n’；‘\n’ 表示换行符</li>
</ul>
<ul>
<li><p>C语言中，<code>char</code>的<strong>本质是一个整数</strong>，在输出时，是ASCII码对应的字符。</p>
<ul>
<li>ASCII 表 <a href="http://ascii.911cha.com/" target="_blank" rel="noopener">http://ascii.911cha.com/</a></li>
</ul>
</li>
<li><p>可以直接给char赋一个整数97，然后输出时，会按照对应的ASCI字符输出97 对应的字符c</p>
</li>
<li><p>char类型是<strong>可以进行运算</strong>的，相当于一个整数，因为它都对应有 <code>Unicode码</code></p>
</li>
</ul>
<p><strong>字符类型本质探讨</strong></p>
<ul>
<li>字符型存储到计算机中，需要将字符对应的码值（整数）找出来存储：</li>
</ul>
<p>字符’a’ =&gt; 码值（97）=&gt;二进制（1100001-—存储() 读取：二进制（1100001）=&gt;码值(97)=&gt;字符a =&gt;读取显示</p>
<ul>
<li>字符和码值的对应关系是通过<strong>字符编码表</strong>决定</li>
</ul>
<p><strong>ASCII码介绍</strong>（了解）</p>
<ul>
<li><p>在计算机内部，所有<strong>数据都使用二进制</strong>表示。每一个<code>二进制位（bit）</code>有<strong>0和1两种状态</strong>，因此8个二进制位就可以组合出256种状态，这被称为一个<code>字节（byte）</code>。一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111</p>
</li>
<li><p>ASCII码：上个世纪60年代，<strong>美国</strong>制定了一套<strong>字符编码</strong>，对<strong>英语字符与二进制位</strong>之间的关系，做了统一规定。<br>这被称为ASCII码。ASCII码一共规定了<strong>127个字符</strong>的编码，比如空格 “SPACE”是32（二进制00100000)大写的字母A是65（二进制0000001）。这128个符号（包括32个不能打印出来的控制符号），<strong>只占用了个字节的后面7位，最前面的1位统一规定为0</strong></p>
</li>
<li><p>缺点：<strong>不能表示所有字符</strong></p>
</li>
</ul>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p><strong>基本介绍</strong></p>
<ul>
<li>C语言标准<strong>（C89）没有定义布尔类型</strong>，所以C语言<strong>判断真假时以0为假，非0为真</strong></li>
<li>但这种做法不直观，所以我们可以借助C语言的宏定义。</li>
<li>C语言标准<strong>(C99)</strong>提供了<strong>_Bool型，  _</strong>Bool仍是<strong>整数类型</strong>，但与一般整型不同的是，<strong>__Bool变量只能赋值为0或1非0的值都会被存储为1</strong>，C99还提供了一个<code>头文件&lt; stdbool.h&gt;</code>定义了bool代表__Bool<strong>,true代表1</strong>， <strong>false代表0</strong>.只要导入 &lt;stdbool.h&gt;，就能方便的操作布尔类型了，比如 bool flag= false；</li>
</ul>
<h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><ul>
<li>当C程序在进行赋值或者运算时，<strong>精度小</strong>的类型<strong>自动转换</strong>为<strong>精度大</strong>的数据类型，这个就是自动类型转换</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200705112029.png" alt="image-20200705112028587"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200705111940.png" alt="image-20200705111937416"></p>
<p><strong>自动类型转换细节</strong></p>
<ul>
<li>有<strong>多种类型</strong>的数据<strong>混合运算</strong>时，系统首先<strong>自动将所有数据转换成精度最大</strong>的那种数据类型，然后再进行计算（如int型和 short型运算时，先把 short转成int型后再进行运算）。</li>
<li>若两种类型的<strong>字节数不同</strong>，<strong>转换成字节数大的类型</strong>，若两种类型的<strong>字节数相同</strong>，且一种<strong>有符号</strong>，一种<strong>无符号</strong>，则<strong>转换成无符号类型</strong></li>
<li>在<strong>赋值运算</strong>中，赋值号两边量的<strong>数据类型不同</strong>时，<strong>赋值号右边</strong>的类型将<strong>转换</strong>为<strong>左边的类型</strong>，<strong>右边变量的数据类型长度比左边长</strong>时，<strong>丢失一部分数据</strong>，这样<strong>会降低精度</strong>，丢失的部分按<strong>四舍五入向前舍入</strong></li>
</ul>
<p><strong>强制类型转换</strong></p>
<ul>
<li>将<strong>精度高</strong>的数据类型转换为<strong>精度低</strong>的数据类型。使用时要<strong>加上强制转换符（）</strong>，但<strong>可能造成精度降低或溢出</strong>，</li>
<li>(类型名) 表达式 (任何有值都可以称为表达式)，</li>
<li>比如1+2， int num=2这种<strong>强制类型转换操作并不改变操作数本身</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">2.077</span></span><br><span class="line">	<span class="comment">//这里注意，不是进行四舍五入，而是直接截断小数后的部分强制转换只对最近的数有效，</span></span><br><span class="line">	<span class="comment">//如果希望针对更多的表达式转换，使用()</span></span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>)dl;</span><br><span class="line">    <span class="comment">//3*10+6*1.5=30+9.0=39.0</span></span><br><span class="line">    <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)<span class="number">3.5</span>*<span class="number">10</span>+<span class="number">6</span>*<span class="number">1.5</span>;</span><br><span class="line">    <span class="comment">//35.0+9.0=44.0-&gt;int=44</span></span><br><span class="line">    <span class="keyword">int</span> num3 = (<span class="keyword">int</span>)<span class="number">3.5</span>*<span class="number">10</span>+<span class="number">6</span>*<span class="number">1.5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n num3=%d"</span>,num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n num=%d dl=%f"</span>,num,dl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>强制类型转换细节</strong></p>
<ul>
<li>当进行数据的从精度高=&gt;精度低，就需要使用到强制转换()</li>
<li>强转符号只针对于<strong>最近的操作数</strong>有效,使用小括号提升优先级</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="常量的基本概念"><a href="#常量的基本概念" class="headerlink" title="常量的基本概念"></a>常量的基本概念</h3><p><code>常量</code>是固定值，在<strong>程序执行期间不能改变</strong>。这些固定的值，又叫做<code>字面量</code></p>
<p>常量<strong>可以是仼何的基本数据类型</strong>，比如<code>整数常量</code>、<code>浮点常量</code>、<code>字符常量</code>，或<code>字符串字面值</code>(字面形式输入到源代码的值)，也有<code>枚举常量</code>。</p>
<p>常量的值在<strong>定义后不能进行修改</strong></p>
<h3 id="常量分类"><a href="#常量分类" class="headerlink" title="常量分类"></a>常量分类</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><ul>
<li><strong>整数常量</strong>可以是<code>十进制</code>、<code>八进制</code>或<code>十六进制</code>的常量。前缀指定基数：<strong>0x或0X</strong>表示十六进制，<strong>0表示八进制不带前缀则默认表示十进制</strong>。</li>
<li>整数常量也可以带一个后缀，后缀是U和L的组合，<strong>U表示无符号整数</strong>（ unsigned），<strong>L表示长整数</strong>（long）。<strong>后缀可以是大写，也可以是小写，U和L的顺序任意</strong></li>
</ul>
<p>🌰举例</p>
<ul>
<li>2077 十进制</li>
<li>0X81D 十六进制</li>
<li>04035  八进制</li>
<li>100000011101 二进制</li>
<li>2077u 无符号整数</li>
<li>2077l 长整数</li>
<li>2077ul 无符号长整数</li>
</ul>
<h4 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h4><p><strong>浮点常量</strong>由<code>整数部分</code>、<code>小数点</code>、<code>小数</code>部分和<code>指数</code>部分组成。小数形式或指数形式都可表示浮点常量。</p>
<p>🌰举例</p>
<ul>
<li>2.07711 double 常量</li>
<li>2.07711E-05  科学计数法</li>
<li>2.0f  float常量</li>
</ul>
<h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p><strong>字符常量</strong>是<strong>括在单引号</strong>中，例如，’x’可以存储在<strong>char类型</strong>的变量中。字符常量可以是一个普通的字符（例如’x’）、一个转义字符(‘\n’ 换行)</p>
<h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><p>字符串字面值或常量是<strong>括在双引号</strong>“中的。一个字符串包含类似于字符常量的字符：<code>普通的字符</code>、<code>转义字符</code>和<code>通用字符</code>。可以使用<strong>空格做分隔符</strong>，对字符串常量进行分割</p>
<h3 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h3><p><strong>定义常量的方式</strong></p>
<ul>
<li>使用<code>#define预处理器</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define 常量名 常量值</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="comment">//定义常量PI常量值3.14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area;</span><br><span class="line">    <span class="comment">//半径area = PI*r*r</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">1.2</span>;</span><br><span class="line">    <span class="built_in">print</span>（<span class="string">"面积：%2f"</span>,area);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>const关键字</code>const声明<strong>指定类型的常量</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 数据类型 常量名 ≡ 常量值;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<p><code>const</code>和<code>#define</code>的<strong>区别</strong></p>
<ul>
<li>const定义的常量时，带类型，#define不带类型</li>
<li><code>const</code>是在<strong>编译、运行的时候起作用</strong>，而 <code>#define</code>是在<code>编译的预处理阶段</code>起作用</li>
<li><code>#define</code>只是<strong>简单的替换</strong>，<strong>没有类型检査</strong>。简单的字符串替换会导致<code>边界效应</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B A+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C A/B*3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//分析过程</span></span><br><span class="line">    <span class="comment">//#define是一个简单的替换</span></span><br><span class="line">    <span class="comment">//C= A/A+3*3 = 1/1+3*3 =1+9=10</span></span><br><span class="line">    <span class="comment">// #define B (A+3) C = A/(A+3)*3 = 0</span></span><br><span class="line">    <span class="comment">//1/4 = 0结果被截断 1.0/4 = 0.25</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d"</span>,C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>const常量<strong>可以进行调试</strong>的，<code>#define</code><strong>不能进行调试</strong>的，<strong>预编译阶段</strong>就已经<strong>替换</strong>掉了，调试的时候没有了</p>
</li>
<li><p><code>const</code><strong>不能重定义</strong>，而<code>#define</code>通过<code>#undef</code><strong>取消某个符号的定义</strong>，<strong>再重新定义</strong></p>
</li>
<li><p><code>#define</code>可以配合<code>#ifdef</code>、<code>#ifndef</code>、<code>#endif</code>来使用，可以<strong>让代码更加灵活</strong>，可以通过<code>#define</code>来启动或者关闭调试信息。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2020.04.16"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#indef DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2020.11.19"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符是对数值类型的变量进行运算</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>运算</th>
<th>范例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+2077</td>
<td>2077</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-1119</td>
<td>-1119</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>2077+210</td>
<td>2287</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>2077-210</td>
<td>1867</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>9*9</td>
<td>81</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>1024/512</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模</td>
<td>8%3 <br>3%4<br>0%5</td>
<td>2<br>3<br>0</td>
</tr>
<tr>
<td>++<br>++</td>
<td>先自增，后运算取值<br>先运算取值，后自增</td>
<td>a=1; b=++a<br>a=1; b=a++</td>
<td>a=2,b=2<br>a=2,b=1</td>
</tr>
<tr>
<td>- - <br>- -</td>
<td>先自减，后运算取值<br/>先运算取值，后自减</td>
<td>a=2; b=- -a<br/>a=2; b=a- -</td>
<td>a=1,b=1<br/>a=1,b=2</td>
</tr>
</tbody></table>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><strong>自增：</strong>+ +</p>
<p><strong>作为独立的语句使用：</strong>前++和后++都完全等价于i=i+1；</p>
<p>前++：++i <strong>先自增后赋值</strong></p>
<p>后++：i++<strong>先赋值后自增</strong></p>
<p>🌰<strong>举例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理的流程10/4=2.5=截取整数=&gt;2=&gt;2.00000</span></span><br><span class="line">	<span class="keyword">double</span> d1=<span class="number">10</span>/<span class="number">4</span>; </span><br><span class="line">	<span class="comment">//运算结果保留小数，参与运算数必须有浮点数</span></span><br><span class="line">	<span class="keyword">double</span> d2=<span class="number">10.0</span>/<span class="number">4</span>;</span><br><span class="line">	<span class="comment">//取模的公式 a % b = a - a/b*b </span></span><br><span class="line">	<span class="comment">//求10/3的余数1</span></span><br><span class="line">	<span class="keyword">int</span> res1=<span class="number">10</span>%<span class="number">3</span>;</span><br><span class="line">	<span class="comment">//-10-(-10)/3*3=-10 - (-3)*3=-10+9=-1</span></span><br><span class="line">    <span class="keyword">int</span> res2=<span class="number">-10</span>%<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//10-10/(-3)*-3=10-(-3)*(-3)=1</span></span><br><span class="line">    <span class="keyword">int</span> res3=<span class="number">10</span>%<span class="number">-3</span>;</span><br><span class="line">    <span class="comment">//-10-(-10)/(-3)*(-3)=-1</span></span><br><span class="line">    <span class="keyword">int</span> res4=<span class="number">-10</span>%<span class="number">-3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//++的使用</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//运算规则等价int j=i;i=i+1; =&gt;j=10，i=11</span></span><br><span class="line">    <span class="keyword">int</span> j =i++;</span><br><span class="line">    <span class="comment">//运算规则等价 i=i+1;int k=i; =&gt;i=12，k=12</span></span><br><span class="line">    <span class="keyword">int</span> k =++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h3><p><code>关系运算符</code>的结果要么是<strong>真（非0表示）</strong>,<strong>要么是假（0表示）</strong></p>
<ul>
<li>关系表达式经常用在<strong>if结构</strong>的条件中或循环结构的条件中</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>运算</th>
<th>范例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>相等</td>
<td>416==1119</td>
<td>false 0</td>
</tr>
<tr>
<td>!=</td>
<td>不等</td>
<td>416!=1119</td>
<td>true 非0</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>416 &lt; 1119</td>
<td>true 非0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>416 &gt; 1119</td>
<td>false 0</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>416 &lt;= 1119</td>
<td>true 非0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>416 &gt;= 1119</td>
<td>false 0</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>用于连接多个条件（一般来讲就是<strong>关系表达式</strong>），最终的结果要么是<strong>真(非0表示)</strong>，要么是<strong>假(0表示)</strong></p>
<p>🌰举例<strong>A为真 B为假</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑与  有假即假</td>
<td>A&amp;&amp;B (真&amp;&amp;假) =&gt; 假</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或  有真即真</td>
<td>A||B (真&amp;&amp;假) =&gt; 真</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非 逆转操作 假=&gt;真; 真=&gt;假</td>
<td>!(A||B)   真=&gt; 假</td>
</tr>
</tbody></table>
<p><strong>短路现象</strong></p>
<ul>
<li><p>进行<code>&amp;&amp;</code>操作时，如果<strong>第一个条件为 false</strong>，则<strong>后面的条件不再判断,整个结果为假</strong></p>
</li>
<li><p><strong>逻辑与</strong>也称为<strong>短路逻辑与</strong></p>
</li>
<li><p>进行<code>||</code>时，如果<strong>第一个条件为true</strong>，则<strong>不再执行后面的条件，整个结果为真</strong></p>
</li>
<li><p><strong>逻辑或</strong>也称为<strong>短路逻辑或</strong></p>
</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li>运算顺序<strong>从右往左</strong></li>
<li>赋值运算符的<strong>左边只能是变量</strong>，<strong>右边可以是变量、表达式、常量值</strong></li>
<li>复合赋值运算符等价于下面的效果比如：a+=3：等价于a=a+3</li>
<li>注意在运算时，<strong>可能截断小数点后面的部分</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a=a+1.7=&gt;11.7=&gt;11</span></span><br><span class="line"> a+=<span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>



<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p><strong>条件表达式？表达式1：表达式2；</strong></p>
<ul>
<li><p>条件表达式为非0（真），运算后的结果是表达式1；</p>
</li>
<li><p>条件表达式为0（假），运算后的结果是表达式2</p>
</li>
<li><p>表达式1和表达式2要为<strong>可以赋给接收变量的类型（或可以自动转换），否则会有精度损失</strong></p>
</li>
<li><p>三元运算符可以转成if-else语句</p>
</li>
</ul>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><ul>
<li>结合的方向只有三个(<strong>自增自减类，赋值，三元运算符)是从右向左</strong>，<strong>其余都是从左向右</strong></li>
<li><strong>逗号</strong>的<strong>运算符优先级最低</strong></li>
<li>优先级的大概的顺序 <code>算术运算符</code>&gt;<code>关系运算符</code>&gt;<code>逻辑运算符</code>（<strong>逻辑非！除外</strong>）&gt;<code>赋值运算符</code>&gt;<code>逗号运算符</code></li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>C语言对各种<code>变量</code>、<code>函数</code>等命名时使用的<strong>字符序列</strong>称为<strong>标识符</strong></li>
<li><strong>可以自定义名称的符号</strong>都叫<code>标识符</code></li>
</ul>
<p><strong>标识符的命名规则</strong></p>
<ul>
<li><p>由26个英文字母大小写，0-9，__或$组成</p>
</li>
<li><p><strong>数字不可以开头</strong></p>
</li>
<li><p><strong>不可以使用关键字和保留字</strong>，但能包含关键字和保留字</p>
</li>
<li><p>C语言中<strong>严格区分大小写</strong>，<strong>长度无限制</strong></p>
</li>
<li><p><strong>标识符不能包含空格</strong></p>
</li>
</ul>
<p><strong>标识符命名规范</strong></p>
<ul>
<li><p>程序中<strong>不得出现仅靠大小写区分的相似的标识符</strong>intx,X；变量ⅹ与X容易混淆</p>
</li>
<li><p><code>宏定义</code>、<code>枚举常数</code>、<code>常量（只读变量）</code>全用<strong>大写字母命名</strong>，用<strong>下划线分隔单词</strong></p>
</li>
<li><p><strong>定义变量没有初始化</strong>。定义变量时<strong>编译器可能没有清空了这块内存</strong>，它的<strong>值可能是无效的数据</strong>，<strong>运行程序会异常退出</strong></p>
</li>
<li><p><code>变量名</code>、<code>函数名</code>多单词组成时,小驼峰（第一个单词首字母小写）</p>
</li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="十进制与二进制的相互转换"><a href="#十进制与二进制的相互转换" class="headerlink" title="十进制与二进制的相互转换"></a>十进制与二进制的相互转换</h3><p>🌰<strong>举例</strong></p>
<p>​                                                                <strong>128=&gt;1000 0000‬</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200706182905.png" alt="image-20200706182821319"></p>
<p><strong>分析过程</strong></p>
<p><strong>将128不断的对2求余,将余数从低位至高位书写</strong>  得到1000 0000</p>
<p><strong>二进制转换十进制</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br><span class="line">#0*2^0 &#x3D;&gt; 第一个0是最低位的0 二进制数的最低位是从2^0,第二位是2^1...依次类推</span><br><span class="line">(0*2^0 + 0*2^1 + 0*2^2 + 0*2^3 + 0*2^4 + 0*2^5 + 0*2^6 +1*2^7)</span><br><span class="line">0+0+0+0+0+0+0+128 &#x3D; 128</span><br></pre></td></tr></table></figure>

<h3 id="十进制与八进制的相互转换"><a href="#十进制与八进制的相互转换" class="headerlink" title="十进制与八进制的相互转换"></a>十进制与八进制的相互转换</h3><p>🌰<strong>举例</strong></p>
<p>​                                                                <strong>128=&gt;0200</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/06/8594687a70b150b469b36bf252c90d5e.png" alt="image-20200706183055902"></p>
<p><strong>分析过程</strong></p>
<p><strong>将128不断的对8求余,将余数从低位至高位书写</strong>  得到 0200 <strong>前面补0为了与十进制进行区分</strong></p>
<p>八进制转换为十进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0200</span><br><span class="line">#0*8^0 &#x3D;&gt; 第一个0是最低位的0 八进制数的最低位是从8^0,</span><br><span class="line">#0*8^1 &#x3D;&gt; 第二位是8^1...依次类推 </span><br><span class="line">#将每一位得出的结果相加得到的和即为该八进制对应的十进制数</span><br><span class="line">(0*8^0 + 0*8^1 + 2*8^2)</span><br><span class="line">0+0+128 &#x3D; 128</span><br></pre></td></tr></table></figure>

<h3 id="十进制与十六进制的相互转换"><a href="#十进制与十六进制的相互转换" class="headerlink" title="十进制与十六进制的相互转换"></a>十进制与十六进制的相互转换</h3><p>🌰<strong>举例</strong></p>
<p>​                                                                <strong>128=&gt;0x80</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/06/15af0572767c4afbabb3d409e1016b93.png" alt="image-20200706183131200"></p>
<p><strong>分析过程</strong></p>
<p><strong>将128不断的对16求余,将余数从低位至高位书写</strong> 0X80 <strong>0x为十六进制的标识</strong></p>
<p>十六进制转换为十进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x80</span><br><span class="line">#0*16^0 &#x3D;&gt; 第一个0是最低位的0 十六进制数的最低位是从16^0,第二位是16^1...依次类推</span><br><span class="line">#0*16^1 &#x3D;&gt; 第二位是16^1...依次类推 </span><br><span class="line">#将每一位得出的结果相加得到的和即为该十六进制对应的十进制数</span><br><span class="line">(0*16^0 + 8*16^1)</span><br><span class="line">0+128 &#x3D; 128</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=133" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>


]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法基本介绍</title>
    <url>/posts/e427/</url>
    <content><![CDATA[<h2 id="数据结构及相关概念"><a href="#数据结构及相关概念" class="headerlink" title="数据结构及相关概念"></a>数据结构及相关概念</h2><p>程序设计的实质是<code>数据表示</code>和<code>数据处理</code></p>
<ul>
<li><p><code>数据表示</code>的核心是<code>数据结构</code></p>
</li>
<li><p><code>数据处理</code>的核心是<code>算法</code></p>
</li>
</ul>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<p>计算机求解的问题分为数值问题和非数值问题</p>
<p><strong>非数据问题的数据组织和处理</strong></p>
<ul>
<li><p>数据的<strong>逻辑结构</strong>：<code>线性表，树，图</code>等数据结构<strong>核心是如何组织待处理的数据及数据之间的关系</strong></p>
</li>
<li><p>数据的<strong>存储结构</strong>：如何将<code>线性表，树，图</code>等数据结构存储到计算机的存储器中<strong>核心是如何有效存储数据及数据之间的逻辑关系</strong></p>
</li>
<li><p><strong>算法</strong>：如何基<strong>于数据的某种存储结构</strong>实现<strong>增加，修改，删除，查找</strong>等基本操作,<strong>核心是如何有效处理地处理数据</strong></p>
</li>
<li><p>常用<strong>数据处理技术</strong>：<code>查找，排序，索引</code> </p>
</li>
</ul>
<h4 id="存储结构分类"><a href="#存储结构分类" class="headerlink" title="存储结构分类"></a>存储结构分类</h4><p><a href="https://blog.csdn.net/bbc955625132551/article/details/72629470" target="_blank" rel="noopener">https://blog.csdn.net/bbc955625132551/article/details/72629470</a></p>
<ul>
<li><p><strong>顺序存储方式</strong>：顺序存储方式是指将所有的数据元素放在一段连续的存储空间中，并使逻辑上相邻的数据元素其对应的物理存储位置也是相邻的（即保证逻辑位置关系与物理位置关系的一致）。顺序存储结构通常借助程序设计语言中的数组来加以实现。</p>
</li>
<li><p><strong>链式存储方式</strong>：链式存储方式不需要将逻辑上相邻的元素存储在物理位置相邻的位置，也就是说数据元素的存储具有任意性。每个数据元素所对应的存储表示由两部分组成，一部分存储元素值本身，另一部分用于存放表示逻辑关系的指针。我们可以认为指针给出的是下一个数据元素的存储地址。</p>
</li>
<li><p><strong>索引存储方式</strong>：索引存储方式在存储数据元素的同时还增加了一个索引表。索引表中的每一项包括关键字和地址，关键字是能够唯一标示一个数据元素的数据项，地址是指示数据元素的存储地址或者存储区域的首地址的。</p>
</li>
<li><p><strong>散列存储方式</strong>：散列存储也称为哈希存储，这种存储方式将数据元素存储在一个连续的区域，每一个数据元素的具体存储位置是根据该数据的关键字值，通过散列（哈希）函数直接计算出来的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/7ffe/</url>
    <content><![CDATA[<h2 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h2><p><code>数组</code>可以存放多个<strong>同一类型数据</strong>。数组也是一种数据类型，是<strong>构造类型</strong>。传递是以<strong>引用的方式传递</strong>（即传递的是<strong>地址</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型  数组名 [数组大小] 数组最多可以存放5个int类型的数据</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200713163638.png" alt="image-20200713102917446"></p>
<ul>
<li><strong>数组名就代表该数组的首地址</strong>，即arr[0] </li>
<li>数组的<strong>各个元素</strong>是<strong>连续分布</strong>的，假如arr[0] 的地址是0x6422016  arr[1] 的地址是0x642201A  arr[0] 的地址是0x642201E …… arr[n] 的地址 = arr[n-1]的地址 + int的字节数(4)</li>
</ul>
<p><strong>3种初始化数组的方式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">3</span>];</span><br><span class="line">	arr1[<span class="number">0</span>] = <span class="number">2077</span>;</span><br><span class="line">	arr1[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">	arr1[<span class="number">0</span>] = <span class="number">19</span>;</span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">3</span>] = &#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> arr2[] = &#123;<span class="number">2077</span>,<span class="number">11</span>,<span class="number">19</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组使用注意事项和细节</strong></p>
<ul>
<li><p>数组是多个<strong>相同类型数据的组合</strong>，数组声明/定义后，<strong>长度是固定的，不能动态变化</strong></p>
</li>
<li><p>数组<strong>创建后没有赋值</strong>，<strong>全局数组默认值0非全局数组初值是机器垃圾值</strong>（即：原来系统分配给这块空间的值）</p>
</li>
<li><p>使用数组的步骤1.<strong>定义</strong> 2.给数组各个元素<strong>赋值</strong> 3.<strong>使用</strong>数组，</p>
</li>
<li><p>数组的<strong>下标是从0开始</strong>的，不是从1开始</p>
</li>
<li><p>数组<strong>下标必须在指定范围内使用</strong>，编译通过，在运行时会因<strong>为数组越界而异常中断</strong></p>
</li>
<li><p>C语言的数组属<strong>构造类型</strong>，<strong>引用传递（传递的是地址）</strong>，因此当把一个数组传递给一个函数时或者变量，函数）变量<strong>操作数组会影响到原数组.</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//2077 + 1</span></span><br><span class="line">    arr[<span class="number">0</span>] = arr[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">2077</span>,<span class="number">2078</span>,<span class="number">2079</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    func(arr);</span><br><span class="line">    <span class="comment">//2078,2078,2079</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"arr[%d] = %d"</span>,i,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                      <strong>内存图分析</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200713110227.png" alt="image-20200713110134628"></p>
<h2 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h2><p>存放字符的数组称为<code>字符数组</code>，给部分数组元素赋值字符数组实际上是<strong>一系列字符的集合</strong>，就是<code>字符串(String)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部分元素赋值</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>] = &#123;<span class="string">'c'</span>,<span class="string">'y'</span>,<span class="string">'b'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">' '</span>,<span class="string">'p'</span>,<span class="string">'u'</span>,<span class="string">'n'</span>,<span class="string">'k'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串</strong></p>
<p><strong>字符串注意事项</strong></p>
<ul>
<li><p>C语言中字符串实际上是使用<strong>null字符(“\0”)</strong>终止的一维字符数组。一个以null结尾的字符串，包含了组成字符串的字符。</p>
</li>
<li><p><code>“\0”</code>是ASCII码表中的<strong>第0个字符</strong>，用NULL表示，称为<strong>空字符</strong>。该字符<strong>既不能显示，也不是控制字符，输出该字符不会有任何效果，C语言中仅作为字符串的结束标志</strong>。</p>
</li>
</ul>
<p>​                                                                                <strong>内存图分析</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200713170117.png" alt="image-20200713165957925"></p>
<p><strong>字符数组赋值时</strong></p>
<ul>
<li>赋给的元素的个数<strong>小于该数组的长度</strong>，则会<strong>自动在后面加</strong><code>“\0”</code>，表示<strong>字符串结束</strong>，</li>
<li>赋给的元素的个数<strong>等于该数组的长度</strong>，则<strong>不会自动添加“\0</strong>”  <strong>会在末尾添加一个乱码</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http乱码 </span></span><br><span class="line"><span class="keyword">char</span> h1[<span class="number">4</span>] = &#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>&#125;; </span><br><span class="line"><span class="comment">//http 或者 http乱码</span></span><br><span class="line"><span class="keyword">char</span> h1[] = &#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动补"\0"</span></span><br><span class="line"><span class="keyword">char</span> h[] = <span class="string">"http"</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/13/cf25b28ea6e66f87691db9a9f1817e62.png" alt="image-20200713171829040"></p>
<p><strong>字符指针指向字符串</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *pStr = <span class="string">"https"</span></span><br><span class="line"><span class="comment">//输出str指向的字符串    </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,pStr);</span><br></pre></td></tr></table></figure>

<ul>
<li>C语言对<strong>字符串常量</strong>“http”是按<strong>字符数组</strong>处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量pStr时只是把<strong>字符串首地址</strong>（即存放字符串的字符数组的首地址）赋给<strong>pStr</strong></li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200713173413.png" alt="image-20200713173408536"></p>
<p><code>字符指针变量</code>和<code>字符数组</code>两种方法表示字符串比较</p>
<ul>
<li><code>字符数组</code>由若干个元素组成,<strong>每个元素放一个字符</strong>；<code>字符指针变量</code>中存放的是<strong>地址</strong>(字符串/字符数组的首地址)不<strong>是将字符串放到字符指针变量中</strong>（是字符串首地址）</li>
<li>对字符数组只能对<strong>各个元素赋值</strong>，不能用以下方法对字符数组赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> h[<span class="number">5</span>];</span><br><span class="line">h[<span class="number">0</span>] = <span class="string">'h'</span>;</span><br><span class="line"><span class="comment">//错误 char h[5] = "http";</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义<code>字符数组</code>，有确定的内存地址(即字符数组名是一个常量); 定义<code>字符指针变量</code>，它并未指向某个确定的字符数据，并且可以多次赋值;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> h[<span class="number">5</span>] = &#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>&#125;; </span><br><span class="line"><span class="keyword">char</span> *pStr = <span class="string">"http"</span>;</span><br><span class="line"><span class="comment">//更改指针指向</span></span><br><span class="line">pStr = <span class="string">"https"</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/13/0d255d62adc0a6fd53f72bbb5b5866e1.png" alt="image-20200713175951148"></p>
<p>​                                                                                <strong>字符串相关函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>strcpy(s1,s2);</td>
<td>复制字符串s2到字符串s1</td>
</tr>
<tr>
<td>strcat(s1,s2);</td>
<td>连接字符串s2到字符串s的末尾。</td>
</tr>
<tr>
<td>strlen(s1);</td>
<td>返回字符串s1的长度</td>
</tr>
<tr>
<td>strcmp(s1,s2);</td>
<td>如果s1和s2是相同的，则返回0；如果s1&lt;s2则返回小于0；如果s1&gt;s2则返回大于0；</td>
</tr>
<tr>
<td>strchr(s1,ch);</td>
<td>返回一个指针，指向字符串s1中字符ch的第一次出现的位置。</td>
</tr>
<tr>
<td>strstr(s1,s2);</td>
<td>返回一个指针，指向字符串s1中字符串s2的第一次出现的位置</td>
</tr>
</tbody></table>
<p><strong>字符串(字符数组)使用注意事项和细节</strong></p>
<ul>
<li><p>程序依靠检测<code>“\0”</code>的位置来<strong>判定字符串是否结束</strong>，而<strong>不是根据数组的长度来决定字符串长度</strong>。<code>字符串</code>长度<strong>不会统计</strong><code>“\0”</code>，<code>字符数组</code>长度会<strong>统计</strong></p>
</li>
<li><p>定义<code>字符数组</code>时应<strong>估计实际字符串长度，保证数组长度始终大于字符串实际长度</strong>，否则输出字符数组时<strong>可能出现未知字符</strong></p>
</li>
<li><p>系统对<code>字符串常量</code>也<strong>自动加一个“\0”作为结束符</strong>。例如”cyberpunk2077”共有13个字符，但在内存中占14字节，最后一个字节”\0”是系统自动加上的。（<strong>通过 sizeof()函数可验证</strong>）</p>
</li>
<li><p>定义<code>字符数组</code>，如果给的<strong>字符个数比数组的长度小</strong>，系统会<strong>默认将剩余的元素空间，全部设置为“\0”</strong>，</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h t t p s \0 \0</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">7</span>] = <span class="string">"https"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符数组定义和初始化的方式比较多</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认后面加"\0"</span></span><br><span class="line"><span class="keyword">char</span> strl[] = &#123;<span class="string">"cyberpunk2077"</span>&#125;;</span><br><span class="line"><span class="comment">//省略&#123;&#125;,默认后面加"\0"</span></span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"cyberpunk2077"</span>;</span><br><span class="line"><span class="comment">//字符数组后面不会加"\0",可能有乱码</span></span><br><span class="line"><span class="keyword">char</span> sti3[] = &#123;<span class="string">'c'</span>,<span class="string">'y'</span>,<span class="string">'b'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">' '</span>,<span class="string">'p'</span>,<span class="string">'u'</span>,<span class="string">'n'</span>,<span class="string">'k'</span>&#125;;</span><br><span class="line"><span class="comment">//字符数组后面不会加"\0",可能有乱码</span></span><br><span class="line"><span class="keyword">char</span> str4[<span class="number">4</span>] = &#123;<span class="string">'h'</span>,<span class="string">'t'</span>,<span class="string">'t'</span>,<span class="string">'p'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *pStr = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=117" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/posts/4523/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>枚举是C语言中的一种<strong>构造数据类型</strong>，它可以<strong>让数据更简洁，更易读</strong>，对于<strong>只有几个有限的特定数据</strong>，可以使用枚举(enumeration,简写enum）</p>
<p>枚举是<strong>一组常量的集合</strong>，包含一组有限的特定的数据</p>
<p><strong>语法定义格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum 枚举名 &#123;枚举元素1,枚举元素2,.....&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//DAY是枚举类型 包含了7个枚举元素</span></span><br><span class="line">	<span class="keyword">enum</span> DAY</span><br><span class="line">	&#123;</span><br><span class="line">    	MON=<span class="number">1</span>,TUE=<span class="number">2</span>,WED=<span class="number">3</span>,THU=<span class="number">4</span>,FRI=<span class="number">5</span>,SAT=<span class="number">6</span>,SUN=<span class="number">7</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//day 是枚举变量</span></span><br><span class="line">	<span class="keyword">enum</span> DAY day;</span><br><span class="line">    <span class="comment">//给枚举变量赋值,值是某个枚举元素</span></span><br><span class="line">	day=WED;</span><br><span class="line">    <span class="comment">//每个枚举元素对应一个值 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d"</span>,day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举的遍历及使用"><a href="#枚举的遍历及使用" class="headerlink" title="枚举的遍历及使用"></a>枚举的遍历及使用</h2><p><strong>遍历</strong></p>
<p>C语言中，<strong>枚举类型</strong>是被当做<code>int</code>或者<code>unsigned int</code>类型来处理的，<strong>枚举类型必须连续是可以实现有条件的遍历</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> day </span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//如果没有给赋值,则会按照顺序赋值</span></span><br><span class="line">	MON=<span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN;</span><br><span class="line">	&#125;day;</span><br><span class="line">	<span class="comment">//表示定义了一个枚举类型 enum Day,同时定义了一个变量枚举day(类型是 enum day)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(day = MON;day&lt;=SUN;day++)&#123;</span><br><span class="line">       <span class="comment">//要求枚举元素是连续赋值 </span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"枚举元素:%d\n"</span>,day);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>swich 使用枚举</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//定义枚举类型 enum SEASONS</span></span><br><span class="line">	<span class="keyword">enum</span> SEASONS&#123; SPRING=<span class="number">1</span>,SUMMER,AUTUMN, WINTER&#125;;</span><br><span class="line">	<span class="comment">//定义了一个枚举类型变量season(类型 enum SEASONS)</span></span><br><span class="line">    <span class="keyword">enum</span> SEASONS seasons;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入你喜欢的季节:1.spring,2.summer,3.autumn,4.winter);"</span>); 		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;season);</span><br><span class="line">	<span class="keyword">switch</span>(season)&#123;</span><br><span class="line">	<span class="keyword">case</span> SPRING: </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"你喜欢的季节是春天"</span>); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SUMMER:</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"你喜欢的季节是夏天"</span>); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AUTUMN:</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"你喜欢的季节是秋天"</span>); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WINTER:</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"你喜欢的季节是冬天"</span>); </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"输入有误"</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用的注意事项和细节</strong></p>
<ul>
<li><p><strong>第一个枚举成员</strong>的<strong>默认值为整型的0</strong>，<strong>后续枚举成员的值</strong>在<strong>前一个成员上加1.</strong></p>
</li>
<li><p>在<strong>定义</strong><code>枚举类型</code>时<strong>改变枚举元素的值</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum DAY&#123;</span><br><span class="line">	&#x2F;&#x2F;如果没有给赋值,会从1开始按照顺序赋值</span><br><span class="line">	MON,TUE,WED,THU&#x3D;9,FRI,SAT,SUN</span><br><span class="line">&#125;day;</span><br><span class="line">	&#x2F;&#x2F;定义了一个枚举类型enum DAY,同时定义了一个变量day</span><br><span class="line">	&#x2F;&#x2F;FRI,SAT,SUN 10,11,12</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>枚举变量</strong>的定义的形式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义枚举类型,再定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> DAY&#123;</span><br><span class="line">	MON=<span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> Day day;</span><br><span class="line"><span class="comment">//定义枚举类型同时定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> DAY&#123;</span><br><span class="line">	MON=<span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;</span><br><span class="line"><span class="comment">//省略枚举类型,直接定义枚举变量,这种形式定义的枚举类型只能使用一次</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	MON=<span class="number">1</span>,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;</span><br></pre></td></tr></table></figure>

<ul>
<li>整数转换为对应的枚举值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> SEASONS&#123; SPRING=<span class="number">1</span>,SUMMER,AUTUMN, WINTER&#125;;</span><br><span class="line">	<span class="comment">//定义了一个枚举类型变量season(类型 enum SEASONS)</span></span><br><span class="line">    <span class="keyword">enum</span> SEASONS season;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">    season = (<span class="keyword">enum</span> SEASONS)n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"season = %d"</span>,season);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=88" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>


]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/posts/3f31/</url>
    <content><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li><p><code>流</code>：数据在<strong>数据源（文件）和程序（内存）</strong>之间经历的<strong>路径</strong></p>
</li>
<li><p><code>输入流</code>：数据从数据源（文件）到程序（内存）的路径</p>
</li>
<li><p><code>输岀流</code>：数据从程序（内存）到数据源（文件）的路径</p>
</li>
<li><p>C标准库<code>stdio.h</code>该头文件<strong>定义了三个变量类型</strong>、一些宏和各种函数来执行输入和输出</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/17/00cea1dabd649b34bdcc2806ec605e8e.png" alt="image-20200717201852928"></p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><code>输入</code>：向程序写入一些数据。输入可以是<strong>以文件的形式或从命令行</strong>中进行。C语言提供了<strong>内置函数</strong>来读取给定的输入，并根据需要<strong>写入到程序中</strong></li>
<li><code>输出</code>，这意味着要在<code>屏幕上、打印机上或任意文件</code>中<strong>显示数据</strong>。C语言提供了<strong>内置函数</strong>来输出数据到<strong>计算机屏幕上和保存数据到文本文件或二进制文件中</strong></li>
</ul>
<h3 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h3><ul>
<li><p>C语言<strong>把所有的设备都当作文件</strong>。设备(比如显示器)<strong>被处理的方式与文件相同</strong>。</p>
</li>
<li><p><code>文件指针</code>是访问文件的方式</p>
</li>
<li><p>C语言中的I/O（输入/输岀）通常使用 <code>printf</code>和 <code>scanf</code>两个函数。 <code>scanf()</code>函数用于从<strong>标准输入（键盘）读取并格式化，</strong> <code>printf()</code>函数发送<strong>格式化输出到标准输出(屏幕)</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>标准文件</th>
<th>文件指针</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入</td>
<td>stdin</td>
<td>键盘</td>
</tr>
<tr>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕</td>
</tr>
<tr>
<td>标准错误</td>
<td>stderr</td>
<td>屏幕</td>
</tr>
</tbody></table>
<p>三个文件会在程序执行时自动打开，以便访问键盘和屏幕</p>
<p><strong>getchar()&amp; putchar()函数</strong></p>
<ul>
<li><code>int getchar(void)</code>函数从屏幕<strong>读取下一个可用的字符，并把它返回为一个整数</strong>。函数在<strong>同一个时间内只会读取一个单一的字符</strong>。循环内使用这个方法，以便从屏幕上读取多个字符。</li>
<li><code>int putchar(int)</code>函数把字符输出到屏幕上，<strong>并返回相同的字符</strong>。函数在<strong>同一个时间内只会输出一个单一的字符</strong>。循环内使用这个方法，以便从屏幕上读取多个字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nYou entered: "</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>gets()&amp; puts()函数</strong></p>
<ul>
<li><code>char*gets(char *s)</code>函数从 stdin<strong>读取一行到s所指向的缓冲区，直到一个终止符或EOF</strong></li>
<li><code>Int puts(const char*s)</code>函数把<strong>字符串s和一个尾随的换行符写入到 stdout</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\nYou entered: "</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scanf()&amp;printf0函数</strong></p>
<ul>
<li><p><code>int scanf(const char* format，…)</code>函数从<strong>标准输入流 stdin读取输入</strong>，并根据提供的 format来浏览输入。</p>
</li>
<li><p><code>int printf(const char* format，…)</code>函数把输出写入到<strong>标准输出流 stdout</strong>，<strong>根据提供的格式产生输出</strong></p>
</li>
<li><p><code>format</code>可以是一个简单的<strong>常量字符串</strong>，可以分别指定<code>%s、%d、%c、%f</code>等来输出或<strong>读取字符串、整数字符或浮点数</strong>。根据需要使用对应的格式选项。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, str, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\nYou entered: %s %d "</span>, str, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><ul>
<li>无论是文本文件还是二进制文件，<strong>代表了一系列的字节</strong>。C语言不仅提供了访问顶层和底层(OS)调用来处理存储设备上的文件。</li>
</ul>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>使用<code>fopen()</code>函数来<strong>创建一个新的文件或者打开一个已有的文件</strong>，这个调用会<strong>初始化类型FILE的一个对象</strong>，<strong>类型FILE包含了所有用来控制流的必要的信息</strong>。函数调用的原型<code>FILE *fopen(const char *filename, const char mode)</code></p>
<ul>
<li><p><strong>filename是字符串，用来命名文件，mode是访问模式的值</strong></p>
</li>
<li><p>如果处理的是二进制文件(图片,视频)，则需使用下面的访问模式：”rb”，”wb”，”ab”，”rb+”，”r+b”，”wb+”，”w+b”<br>“ab+”，”a+b”(b代表二进制)</p>
</li>
</ul>
<p><strong>函数说明</strong></p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>打开一个已有的文本文件，允许读取文件</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，程序会从文件的开头写入内容。<strong>如果文件存在，则该会被截断为零长度，重新写入！。</strong></td>
</tr>
<tr>
<td>a</td>
<td>打开一个文本文件，以<strong>追加模式</strong>写入文件。如果文件不存在，则会创建一个新文件。在这里，程序会在已有的文件内容中追加内容</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文本文件，允许读写文件</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><code>fclose()</code>函数。函数的原型如下int fclose(FILEfp)</p>
<ul>
<li><strong>成功关闭文件， fclose()函数返回零</strong>，<strong>关闭文件时发生错误，函数返回EOF</strong>。<code>fclose()</code>函数，<strong>会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存</strong>。<code>EOF</code>是一个定义在头文件<code>&lt;stdio. h&gt;</code>中的<strong>常量</strong>。</li>
<li>C标准库提供了各种函数来<strong>按字符或者以固定长度字符串的形式读写文件。</strong></li>
<li><strong>使用完文件后(读,写)，一定要将该文件关闭</strong></li>
</ul>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p><strong>把字符写入到流</strong>中的函数<code>int fputc(int c, FILE *fp)</code>;</p>
<ul>
<li>说明：函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果<strong>写入成功，它会返回写入的字符</strong>，<br>如果<strong>发生错误，则会返回</strong> <code>EOF</code>。</li>
<li><code>int fputs(const char *s, FILE *fp)</code>;把一个以 null 结尾的字符串写入到流中：<br>说明：函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果<strong>写入成功，它会返回一个非负值</strong>，如果<strong>发生</strong><br><strong>错误，则会返回</strong> <code>EOF</code>。也可以使用 <code>int fprintf(FILE *fp,const char *format, ...)</code>函数来写<strong>把一个字符串写入到文件中</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打开该文件 w+ 模式是 文件会被截断为零长度</span></span><br><span class="line">    fp = fopen(<span class="string">"d:/java.txt"</span>, <span class="string">"w+"</span>); </span><br><span class="line">    <span class="comment">//fp = fopen("d:/test100.txt", "a+");</span></span><br><span class="line">    <span class="comment">//将内容写入到文件中</span></span><br><span class="line">    <span class="comment">/*fprintf(fp, "hello world java~~\n");</span></span><br><span class="line"><span class="comment">    fputs("hello world go~~\n", fp);*/</span></span><br><span class="line">    <span class="comment">//关闭文件!</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"创建，写入信息完成"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ul>
<li><strong>从文件读取单个字符</strong>的函数<code>int fgetc( FILE * fp )</code>;<br>说明：fgetc() 函数从 fp 所指向的输入文件中读取一个字符。<strong>返回值是读取的字符，如果发生错误则返回</strong> <code>EOF</code>。</li>
<li><strong>从流中读取一个字符串</strong>：<code>char *fgets(char *buf, int n, FILE *fp)</code>;<ul>
<li>说明：函数 fgets() 从 fp 所指向的输入流中<strong>读取 n - 1 个字符</strong>。<strong>把读取的字符串复制到<code>缓冲区 buf</code>，并在</strong><br><strong>最后追加一个 <code>null 字符</code>来终止字符串。</strong><br>如果这个函数在<strong>读取最后一个字符之前</strong>就遇到一个<strong>换行符 ‘\n’ 或文件的末尾 EO</strong>F，则<strong>只会返回读取到的字符，</strong><br><strong>包括换行符。</strong></li>
<li>也可使用<code>int fscanf(FILE *fp, const char *format, ...)</code> 函数来<strong>从文件中读取字符串</strong>，但是在<strong>遇到第一个空格字符</strong><br><strong>时，它会停止读取。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//定义一个缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fp = fopen(<span class="string">"d:/java.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="comment">//方法 1</span></span><br><span class="line">    <span class="comment">//fscanf(fp, "%s", buff);</span></span><br><span class="line">    <span class="comment">////输出</span></span><br><span class="line">    <span class="comment">//printf("%s\n", buff);</span></span><br><span class="line">    <span class="comment">//方法 2 读取整个文件</span></span><br><span class="line">    <span class="comment">//说明，循环读取 fp 指向的文件内容，如果读到 NULL,就结束</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buff, <span class="number">1024</span>,fp)!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/posts/805/</url>
    <content><![CDATA[<h1 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h1><h2 id="1-1什么是泛型"><a href="#1-1什么是泛型" class="headerlink" title="1.1什么是泛型"></a>1.1什么是泛型</h2><p><strong>泛型的概念</strong></p>
<ul>
<li><p>Java 泛型（generics）是 <code>JDK 5</code> 中引入的一个新特性,考虑到<code>向前兼容</code>，编译器是<strong>允许非泛型集合与泛型集合互相赋值</strong> ,泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序在编译时检测到非法的类型。</p>
</li>
<li><p>泛型的<strong>本质</strong>是<strong>参数化类型</strong>,也就是说<strong>所操作的数据类型被指定为一个参数</strong>,泛型的<strong>参数只可以代表类</strong>，不能代表个别对象。由于 Java <strong>泛型的类型参数之实际类型在编译时会被消除</strong>，<strong>所以无法在运行时得知其类型参数的类型</strong>。</p>
</li>
</ul>
<p><strong>参数化类型</strong></p>
<ul>
<li><p><strong>将类型由原来的具体的类型参数化</strong>，然后在<strong>使用/调用时传入具体的类型</strong>这种参数类型可以用在类、方法和接口中，分别被称为<code>泛型类、泛型方法、泛型接口</code></p>
</li>
<li><p>编译器在<strong>编译泛型时会自动加入类型转换的编码</strong>，故<strong>运行速度不会因为使用泛型而加快</strong></p>
</li>
</ul>
<p><strong>泛型定义格式</strong></p>
<ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是<strong>形参</strong></li>
<li>&lt;类型1类型2…&gt;：指定<strong>多种类型的格式，多种类型之间用逗号隔开</strong>。这里的类型可以看成是形参将来具体调用时候给定的类型可以看成是实参，并且<strong>实参的类型只能是引用数据类型（类,接口,数组）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParadigmDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">"数据结构和算法"</span>);</span><br><span class="line">        c.add(<span class="string">"C语言程序设计"</span>);</span><br><span class="line">        c.add(<span class="string">"Java入门到放弃"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : c) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c.add(<span class="number">1379</span>);</span><br><span class="line">String str  = (String) it.next();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericParadigmDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">"数据结构和算法"</span>);</span><br><span class="line">        c.add(<span class="string">"C语言程序设计"</span>);</span><br><span class="line">        c.add(<span class="string">"Java入门到放弃"</span>);</span><br><span class="line">        c.add(<span class="number">1379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : c) &#123;</span><br><span class="line">            <span class="comment">//Object obj = it.next();</span></span><br><span class="line">            <span class="comment">//System.out.println(obj);</span></span><br><span class="line">            String str = (String) o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/27/8ad03da66217574b46ae446756602527.png" alt="image-20200627133508630"></p>
<p><strong>运行后出现</strong><code>ClassCastException</code></p>
<ul>
<li><p>原因  c.add(1379)存储的是Integer类型,for循环里面的是String 类型不匹配</p>
</li>
<li><p>集合未指定数据类型</p>
</li>
<li><p>程序包含了<code>ClassCastException</code></p>
</li>
</ul>
<p><strong>解决方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c &#x3D; new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/06/27/13c091f1900ba0c4c0fec3bd207aa91f.png" alt="image-20200627150124943"></p>
<p><strong>使用泛型将运行时的异常提到了编译期</strong></p>
<p>如果使用<code>迭代器遍历</code>集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">     <span class="comment">//向上转型</span></span><br><span class="line">     String str = (String)it.next();</span><br><span class="line">     System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型后,<strong>避免了强制类型转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    String str = it.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2泛型类"><a href="#1-2泛型类" class="headerlink" title="1.2泛型类"></a>1.2泛型类</h2><ul>
<li><strong>泛型类</strong>的定义格式</li>
<li>修饰符 class 类名 &lt;类型&gt;{}</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T表示任意标识,常见的T,E,K,V</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-1普通方法"><a href="#1-2-1普通方法" class="headerlink" title="1.2.1普通方法"></a>1.2.1普通方法</h3><ul>
<li>Game游戏类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Player玩家类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span> <span class="params">(Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Test测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Player p = <span class="keyword">new</span> Player();</span><br><span class="line">        p.setAge(<span class="number">18</span>);</span><br><span class="line">        System.out.println(p.getAge());</span><br><span class="line"></span><br><span class="line">        Game g = <span class="keyword">new</span> Game();</span><br><span class="line">        g.setName(<span class="string">"Cyberpunk2077"</span>);</span><br><span class="line">        System.out.println(g.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用泛型让一个方法<strong>接受不同的参数类型</strong></p>
<p>修改<code>Game</code>为泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>Test</code>类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置泛型参数为String</span></span><br><span class="line">Game&lt;String&gt; g = <span class="keyword">new</span> Game&lt;String&gt;();</span><br><span class="line">g.setT(<span class="string">"Cyberpunk2077"</span>);</span><br><span class="line">System.out.println(g1.getT());</span><br><span class="line"><span class="comment">//设置泛型参数为Ineger</span></span><br><span class="line">Game&lt;Integer&gt; g2 = <span class="keyword">new</span> Game&lt;Integer&gt;();</span><br><span class="line">g2.setT(<span class="number">18</span>);</span><br><span class="line">System.out.println(g2.getT());</span><br></pre></td></tr></table></figure>

<p><strong>实现了相同效果,减少了一个类的创建</strong></p>
<h3 id="1-2-2方法重载"><a href="#1-2-2方法重载" class="headerlink" title="1.2.2方法重载"></a>1.2.2方法重载</h3><ul>
<li>1.创建一个Game类(重载)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attribute</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attribute</span><span class="params">(Integer price)</span></span>&#123;</span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attribute</span><span class="params">(<span class="keyword">boolean</span> ontime)</span></span>&#123;</span><br><span class="line">        System.out.println(ontime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.Test类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Game g = <span class="keyword">new</span> Game();</span><br><span class="line">    g.attribute(<span class="string">"Cyberpunk2077"</span>);</span><br><span class="line">    g.attribute(<span class="number">298</span>);</span><br><span class="line">    g.attribute(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.如果再次添加属性,需要Game类中添加,才能使得新添加的属性生效</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attribute</span><span class="params">(<span class="keyword">double</span> time)</span></span>&#123;</span><br><span class="line">        System.out.println(time);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">g.attribute(<span class="number">2020.11</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用泛型类改进</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attribute</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game&lt;String&gt; g1 = <span class="keyword">new</span> Game&lt;String&gt;();</span><br><span class="line">        g1.attribute(<span class="string">"Cyberpunk2077"</span>);</span><br><span class="line">        Game&lt;Integer&gt; g2 = <span class="keyword">new</span> Game&lt;Integer&gt;();</span><br><span class="line">        g2.attribute(<span class="number">298</span>);</span><br><span class="line">        Game&lt;Boolean&gt; g3 = <span class="keyword">new</span> Game&lt;Boolean&gt;();</span><br><span class="line">        g3.attribute(<span class="keyword">false</span>);</span><br><span class="line">        Game&lt;Double&gt; g4 = <span class="keyword">new</span> Game&lt;Double&gt;();</span><br><span class="line">        g4.attribute(<span class="number">2020.11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3泛型方法"><a href="#1-3泛型方法" class="headerlink" title="1.3泛型方法"></a>1.3泛型方法</h2><ul>
<li><strong>泛型方法</strong>的定义格式</li>
<li>修饰符&lt;类型&gt; 返回值类型 方法名 （类型 变量名){ }</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">attribute</span><span class="params">(T t)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Game</code>类 调用方法时才明确参数的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">attribute</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Test类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game g = <span class="keyword">new</span> Game();</span><br><span class="line">        g.attribute(<span class="string">"Cyberpunk2077"</span>);</span><br><span class="line">        g.attribute(<span class="number">298</span>);</span><br><span class="line">        g.attribute(<span class="keyword">false</span>);</span><br><span class="line">        g.attribute(<span class="number">2020.11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4泛型接口"><a href="#1-4泛型接口" class="headerlink" title="1.4泛型接口"></a>1.4泛型接口</h2><ul>
<li><strong>泛型接口</strong>的定义格式</li>
<li>修饰符 interface 接口名&lt;类型&gt;{ }</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Game</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Game</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attribute</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>测试类无法直接使用接口,接口没有<code>实例化</code></strong></p>
</li>
<li><p>创建<strong>接口的实现类</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Game</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attribute</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Test</code>类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game&lt;String&gt; g1 = <span class="keyword">new</span> GameImpl&lt;String&gt;();</span><br><span class="line">        g1.attribute(<span class="string">"Cyberpunk2077"</span>);</span><br><span class="line">        Game&lt;Integer&gt; g2 = <span class="keyword">new</span> GameImpl&lt;Integer&gt;();</span><br><span class="line">        g2.attribute(<span class="number">298</span>);</span><br><span class="line">        Game&lt;Boolean&gt; g3 = <span class="keyword">new</span> GameImpl&lt;Boolean&gt;();</span><br><span class="line">        g3.attribute(<span class="keyword">false</span>);</span><br><span class="line">        Game&lt;Double&gt; g4 = <span class="keyword">new</span> GameImpl&lt;Double&gt;();</span><br><span class="line">        g4.attribute(<span class="number">2020.11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>参考连接</li>
<li><a href="https://www.bilibili.com/video/BV1gb411F76B?p=252" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1gb411F76B?p=252</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/posts/7712/</url>
    <content><![CDATA[<h1 id="1-栈和队列"><a href="#1-栈和队列" class="headerlink" title="1.栈和队列"></a>1.栈和队列</h1><p>在数组中，我们可以通过索引访问<code>随机</code>元素。 但是，在某些情况下，我们可能想要限制处理顺序。</p>
<p>两种不同的处理顺序，<code>先入先出</code>和<code>后入先出</code>；以及两个相应的线性数据结构，<code>队列</code>和<code>栈</code>。</p>
<h3 id="示例-队列"><a href="#示例-队列" class="headerlink" title="示例 - 队列"></a>示例 - 队列</h3><p><strong>先入先出的数据结构</strong></p>
<hr>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/01/9e25e27f353f85d8ea00d178be89ee1f.png" alt="screen-shot-2018-05-03-at-151021">首先处理添加到队列中的<code>第一个元素</code>添加到<code>队列</code></p>
<p>如上图所示，队列是典型的 <strong>FIFO(First Input First Output)</strong> 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在<code>队列的末尾</code>。 删除（delete）操作也被称为出队（dequeue)。 你只能移除<code>第一个元素</code>。</p>
<hr>
<ul>
<li>入队： <code>Enqueue</code> 将新元素 6 添加到队列中。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/01/b9db84785bc5c01963ef43cdf7baa40f.png" alt="screen-shot-2018-05-02-at-174355"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/01/646bd68a8314b465bd264fdff9c3cf53.png" alt="screen-shot-2018-05-02-at-172840">  Enqueue</p>
<ul>
<li><p>出队：<code>Dequeue</code> 查看将删除元素。</p>
<p>Dequeue</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn@master/2020/07/01/646bd68a8314b465bd264fdff9c3cf53.png" alt="screen-shot-2018-05-02-at-172840"></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200703092516.png" alt="screen-shot-2018-05-02-at-175409"></p>
<h4 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<ul>
<li>难度简单</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>🔗<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/" target="_blank" rel="noopener">题解参考链接</a></p>
<h3 id="示例-栈"><a href="#示例-栈" class="headerlink" title="示例 - 栈"></a>示例 - 栈</h3><p>与<code>队列</code>不同<code>栈</code>是一个 <strong>LIFO(Last In First Out )</strong>  数据结构。通常，</p>
<p>插入操作,入栈 <code>push</code> ,与队列类似，总是在<strong>堆栈的末尾添加一个新元素</strong></p>
<p>举例说明🌰</p>
<ul>
<li>入栈顺序 1=&gt;2 =&gt;3 =&gt;4 =&gt;5</li>
</ul>
<p>删除操作,出栈 <code>pop</code> ，元素始终<strong>栈堆的末尾弹出</strong></p>
<p>举例说明🌰</p>
<ul>
<li>入栈顺序 5=&gt;4 =&gt;3 =&gt;2 =&gt;1</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200703095049.png" alt="screen-shot-2018-06-02-at-203523"></p>
<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h4><ul>
<li>难度简单</li>
</ul>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在<strong>队列尾部插入</strong>整数和在<strong>队列头部删除整数</strong>的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<p>🔗<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-2/" target="_blank" rel="noopener">题解参考链接</a></p>
<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">剑指 Offer 30. 包含min函数的栈</a></h4><ul>
<li>难度简单</li>
</ul>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>各函数的调用总次数不超过 20000 次</li>
</ol>
<p>🔗<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/" target="_blank" rel="noopener">题解参考链接</a></p>
<h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></h4><ul>
<li>难度中等</li>
</ul>
<p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
<p>🔗<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/" target="_blank" rel="noopener">题解参考链接</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指offer</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理命令</title>
    <url>/posts/3c59/</url>
    <content><![CDATA[<h2 id="预处理命令基本介绍"><a href="#预处理命令基本介绍" class="headerlink" title="预处理命令基本介绍"></a><strong>预处理命令基本介绍</strong></h2><ul>
<li><p>使用库函数之前，应该用<code>#include</code>引入对应的头文件。这种<strong>以#号开头的命令称为预处理命令。</strong></p>
</li>
<li><p>这些在编译之前对<strong>源文件</strong>进行简单加工的过程，就称为<strong>预处理（即预先处理、提前处理）</strong></p>
</li>
<li><p>预处理主要是处理以#开头的命令，预处理命令要放<strong>在所有函数之外</strong>，<strong>一般都放在源文件的前面</strong></p>
</li>
<li><p>预处理由<strong>预处理程序</strong>完成。当<strong>对源文件进行编译</strong>时，系统将<strong>自动调用预处理程序</strong>对源程序中的预处理部分作处理，<strong>处理完毕自动进入对源程序的编译</strong></p>
</li>
<li><p>C语言提供了多种预处理功能，如<code>宏定义</code>、<code>文件包含</code>、<code>条件编译</code>等，合理地使用会使程序便于<strong>阅读修改、移植和调试，也有利于模块化程序设计</strong></p>
</li>
<li><p><code>Windows平台</code>下<strong>暂停函数</strong>的原型是 <code>void Sleep(DWORD dwMilliseconds)</code>，参数的<strong>单位是“毫秒”</strong>，位于<code>&lt; windows.h&gt;</code>头文件。</p>
</li>
<li><p><code>Linux平台</code>下<strong>暂停函数</strong>的原型是 <code>unsigned int sleep(unsigned int seconds)</code>,参数的<strong>单位是“秒”</strong>，位于<code>&lt; unistd.h&gt;</code>头文件</p>
</li>
<li><p>.#if、#elif、#endif就是预处理命令，它们都是在<strong>编译之前由预处理程序</strong>来执行的。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//windows平台#include&lt;windows.h&gt;</span></span><br><span class="line">#if_WIN32</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//Linux平台#include&lt;unistd.h&gt;</span></span><br><span class="line">#elif_linux_</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//不同的平台下调用不同的函数</span></span><br><span class="line">	#if_WIN32</span><br><span class="line">	Sleep(<span class="number">5000</span>);</span><br><span class="line">	#elif_linux_</span><br><span class="line">	Sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"cyberpunk2077"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p><strong>基本介绍</strong></p>
<ul>
<li>1.<code>#define</code>叫做<strong>宏定义命令</strong>，#表示这是一条预处理命令)。所谓宏定义，就是<strong>用一个标识符来表示一个字符串</strong>，在代码中<strong>出现了该标识符</strong>，那么就<strong>全部替换成指定的字符串</strong></li>
<li>2.宏名是标识符的一种，<strong>命名规则和变量相同</strong>。<strong>字符串</strong>可以是<code>数字</code>、<code>表达式</code>、<code>if语句</code>、<code>函数</code>等</li>
<li>3.<code>#define</code>    宏名  字符串  </li>
<li>4.这里所说的字符串是<strong>一般意义上的字符序列</strong>，<strong>不和C语言中的字符串等同</strong>，<strong>不需要双引号</strong></li>
<li>5.程序中反复使用的表达式就可以使用宏定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>N为<strong>宏名</strong>，100是<strong>宏的内容(宏所表示的字符串)</strong>。<strong>预处理阶段</strong>，对程序中<strong>所有出现的“宏名”</strong>，<code>预处理器</code>都会用宏定义中的字符串去代换，<strong>称为“宏替换”或“宏展开”。</strong></li>
<li><strong>宏定义</strong>是由<strong>源程序中的宏定义命令#define</strong>完成的，<strong>宏替换</strong>是由<strong>预处理程序</strong>完成的</li>
</ul>
<p>🌰<strong>举例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//宏定义，宏名M，对应的字符串（n*n+3*n）</span></span><br><span class="line"><span class="comment">//注意：如果宏对应的字符串有（），那么就不能省略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (n*n+3*n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum,n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input a number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(%d<span class="string">",&amp;n);</span></span><br><span class="line"><span class="string">    //宏展开 3*(n*n+3*n）+4*(n*n+3*n)+5(n*n+3*n); </span></span><br><span class="line"><span class="string">    sum=3*M+4*M+5*M;</span></span><br><span class="line"><span class="string">    printf("</span>sum=%d\n<span class="string">";sum);</span></span><br><span class="line"><span class="string">    return 0;      </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>宏定义注意事项和细节</strong></p>
<ul>
<li>宏展开的过程，只是一种<strong>简单的替换</strong>。<strong>字符串中可以含任何字符，它可以是常数、表达式、if语句、函数等</strong>，<code>预处理程序</code>对它<strong>不作任何检査，只能在宏展开编译后的源程序时发现错误</strong></li>
<li>宏定义不是说明或语句，在<strong>行末不必加分号</strong>，如加上分号则连分号也一起替换</li>
<li>宏定义必须<strong>写在函数之外</strong>，<strong>作用域为宏定义命令起到源程序结束</strong>。如要<strong>终止其作用域</strong>可使用<code>#undef</code>命令</li>
<li>代码中的<strong>宏名被引号包围，预处理程序不对其作宏代替</strong></li>
<li>宏定义<strong>允许嵌套</strong>，在宏定义的字符串中<strong>可以使用已经定义的宏名</strong>，在宏展开时由预处理程序层层代换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s PI*y*y</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,S);</span><br><span class="line"><span class="comment">//在宏替换后变为：</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,<span class="number">3.1415926</span>*y*y);</span><br></pre></td></tr></table></figure>

<ul>
<li>习惯上宏名用<strong>大写字母</strong>表示，以便于与变量区别。但<strong>也允许用小写字母</strong></li>
<li>可用宏定义表示数据类型，使书写方便</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT unsigned int </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//宏替换 unsigned int a,b;</span></span><br><span class="line">	UNIT a,b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>宏定义表示</strong>数据类型和用 <code>typedef</code>定义数据说明符的区别：<ul>
<li>宏定义只是<strong>简单的字符串替换</strong>，由<strong>预处理器来处理</strong>;</li>
<li>typedef是在<strong>编译阶段由编译器处理</strong>的，它并不是简单的字符串替换，而<strong>给原有的数据类型起一个新的名字，将它作为一种新的数据类型。</strong></li>
</ul>
</li>
</ul>
<h3 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h3><p><strong>基本介绍</strong></p>
<ul>
<li><p>C语言允许宏带有参数。在<strong>宏定义</strong>中的参数称为<code>“形式参数”</code>，在<strong>宏调用</strong>中的参数称为<code>“实际参数”</code>，这点和函数有些类似</p>
</li>
<li><p>对带参数的宏，在展开过程中不仅要进行字符串替换，还要用<strong>实参去替换形参</strong></p>
</li>
<li><p><strong>带参宏定义</strong>的一般形式为#define 宏名(形参列表) 字符串，在字符串中可以含有各个形参</p>
</li>
<li><p><strong>带参宏调用</strong>的一般形式为：<code>宏名(实参列表)</code>;</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//1.MAX就是带参数的宏</span></span><br><span class="line"><span class="comment">//2.(a,b)就是形参</span></span><br><span class="line"><span class="comment">//3.(a&gt;b)?a:b 是带参数的宏对应字符串，该字符串中可以使用形参</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b)(a&gt;b) ? a:b </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,<span class="built_in">max</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input two numbers:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d”,&amp;x,&amp;y);</span></span><br><span class="line"><span class="string">	//1.MAX(x,y);调用带参数宏定义</span></span><br><span class="line"><span class="string">	//2.在宏替换时(预处理,由预处理器)，会进行字符串的替换，同时会使用实参，去替换形参</span></span><br><span class="line"><span class="string">	//3.即MAX(x,y) 宏替换后 (x&gt;y)?x:y </span></span><br><span class="line"><span class="string">	max = MAX(x,y);</span></span><br><span class="line"><span class="string">    printf（"</span><span class="built_in">max</span>=%d\n<span class="string">",max);</span></span><br><span class="line"><span class="string">	getchar();</span></span><br><span class="line"><span class="string">    getchar();</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>带参宏定义的注意事项和细节</strong></p>
<ul>
<li>带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b)(a&gt;b)?a:b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX (a,b)(a&gt;b)?a:b</span></span><br><span class="line"><span class="comment">//如果写成了MAX (a,b)(a&gt;b)?a:b将被认为是无参宏定义，</span></span><br><span class="line"><span class="comment">//宏名MAX代表字符串(a,b)(a&gt;b)?a:b 而不是:MAX(a,b)代表(a&gt;b)?a:b</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带参宏定义</strong>中，<strong>不会为形式参数分配内存</strong>，因此<strong>不必指明数据类型</strong>。而在<strong>宏调用</strong>中，<strong>实参包含了具体的数据，要去替换形参</strong>，因此实参必须要指明数据类型</li>
<li>在宏定义中，<strong>字符串内的形参</strong>通常要<strong>用括号括起来</strong>以避免出错</li>
</ul>
<h3 id="带参宏定义和函数的区别"><a href="#带参宏定义和函数的区别" class="headerlink" title="带参宏定义和函数的区别"></a>带参宏定义和函数的区别</h3><ul>
<li><code>宏展开</code>仅仅是<strong>字符串的替换</strong>，<strong>不会对表达式进行计算</strong>；宏在<strong>编译之前就被处理掉</strong>，<strong>没有机会参与编译</strong>，<strong>也不会占用内存。</strong></li>
<li><code>函数</code>是一段可以重复使用的代码，<strong>会被编译</strong>，会给它<strong>分配内存</strong>，每次调用函数，就是<strong>执行这块内存中的代码</strong></li>
</ul>
<p><strong>🌰举例</strong></p>
<ul>
<li>函数计算平方值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SQ</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> ((y) *(y));</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">    	<span class="comment">//1,4,9,16,25</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d ^2=%d\n"</span>,(i<span class="number">-1</span>),SQ(i++));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>宏定义计算平方值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ((y)*(y))</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">    	<span class="comment">//1,9,25 进入循环三次</span></span><br><span class="line">        <span class="comment">//SQ(i++)宏展开 ((i++)*(i++))</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d ^2=%d\n"</span>,(i<span class="number">-1</span>),SQ(i++));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预处理命令总结"><a href="#预处理命令总结" class="headerlink" title="预处理命令总结"></a>预处理命令总结</h2><p><code>预处理指令</code>是<strong>以#号开头的代码行</strong>,#后是指令关键字，(#include  空白字符  &lt;&gt;)在关键字和#号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该<strong>指令将在编译器进行编译之前对源代码做某些转换</strong></p>
<p>​                                                                                  <strong>常见预处理指令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>空指令</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则编译下面代码</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则编译下面代码</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的#给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个#if…#else条件编译块</td>
</tr>
</tbody></table>
<p><strong>预处理指令使用注意事项</strong></p>
<ul>
<li><strong>预处理功能是C语言特有的功能</strong>，对源程序正式编译前<strong>由预处理程序</strong>完成的，程序中<strong>用预处理命令</strong>来调用功能。</li>
<li>宏定义可以带有参数，<strong>宏调用时是以实参代换形参，不是“值传送”</strong></li>
<li>为了避免宏代换时发生错误，<code>宏定义</code>中的<strong>字符串应加括号</strong>，<code>字符串</code>中出现的<strong>形式参数两边也应加括号</strong></li>
<li><strong>文件包含</strong>是预处理的一个重要功能，可以<strong>把多个源文件连接成一个源文件进行编译</strong>，结果将<strong>生成一个目标文件</strong></li>
<li><code>条件编译</code>允许只编译源程序中满足条件的程序段，生成的目标程序较小，<strong>减少内存的开销</strong>并<strong>提髙程序的效率</strong>。</li>
<li><code>预处理</code>功能便于程序的<strong>修改、阅读、移植和调试，也便于实现模块化程序设计</strong></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=111" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>预处理命令</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/posts/82000000/</url>
    <content><![CDATA[<p><strong>定义</strong>：零个或多个数据元素的<strong>有限序列</strong>。<strong>除第一个元素外</strong>，每个元素<strong>有且仅有</strong>一个直接前驱，<strong>除最后一个元素外，每个元素有且仅有一个直接后继。</strong></p>
<p>线性表的特点：</p>
<ul>
<li>1.元素个数有限   </li>
<li>2.元素有先后次序</li>
<li>3.数据类型相同   </li>
</ul>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>线性表的<code>顺序存储结构</code>，指的是用<strong>一段地址连续的存储单元依次存储线性表的数据元素</strong></p>
<p>🌰<code>一维数组</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储空间初始分配量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="comment">//ElemType类型根据实际情况而定，这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//数组存储数据元素,最大值为 MAXSIZE</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">E1</span> <span class="title">emType</span> <span class="title">data</span>[<span class="title">MAXSIZE</span>];</span> </span><br><span class="line">    <span class="comment">//线性表的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p><code>顺序存储结构</code>的属性:</p>
<ul>
<li>存储空间的起始位置：数组data，数组<strong>起始位置</strong>的地址就是数组在内存中的存储位置。</li>
<li>线性表的最大存储容量：数组长度 MaxSize </li>
<li>线性表的当前长度：length</li>
</ul>
<p>内存中的<code>地址</code>，就和图书馆或电影院里的座位一样，都是有编号的。存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p>
<p>假设数组中的第一元素在内存中的地址是<strong>000000000061FE08</strong>, 第二个元素的地址是<strong>000000000061FE0C</strong></p>
<p>原因是数组中存储的<strong>元素的数据类型是int</strong>,int在内存中占4个字节 <strong>08 + 4 =&gt; 0C (16进制),</strong>后面元素的地址在前一个地址的基础上加4即可</p>
<p>算出线性表中<strong>任意位置的地址都是相同的时间</strong>。对每个线性表位置的<code>存入</code>或者<code>取出</code>数据，对于计算机来说都是相等的时间，也就是一个常数，时间复杂度的概念来说，它的存取时间性能为O（1）。我们通常把具有这一特点的存储结构称为<code>随机存取结构</code>。</p>
<h3 id="顺序存储结构的插入和删除"><a href="#顺序存储结构的插入和删除" class="headerlink" title="顺序存储结构的插入和删除"></a>顺序存储结构的插入和删除</h3><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	status是函数的类型，其值是函数结果状态代码，如OK等</span></span><br><span class="line"><span class="comment">	初始条件：顺序线性表L已存在1≤i≤ListLength（L）</span></span><br><span class="line"><span class="comment">	操作结果：用e返回L中第i个数据元素的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">status <span class="title">GetElem</span> <span class="params">(SqList L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L.length==<span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L length)&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR；</span><br><span class="line">	&#125;</span><br><span class="line">	*e = L.data[i<span class="number">-1</span>]; </span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回值类型Sats是一个整型，返回OK代表1， ERROR代表0。</strong></p>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>思路</strong></p>
<ul>
<li>插入位置不合理，抛出异常；</li>
<li>线性表长度大于等于数组长度，则抛出异常或动态增加容量；</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置;</li>
<li>将要插入元素填入位置i处；</li>
<li>表长加1。</li>
</ul>
<p>🌰<strong>插队</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始条件：顺序线性表L已存在，1≤i≤ ListLength(L)，</span></span><br><span class="line"><span class="comment">	操作结果：在工中第i个位置之前插入新的数据元素e，工的长度加1</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span> <span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">//顺序线性表已经满</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt; length == MAXSIZE)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当不在范围内时</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;<span class="number">1</span>ength + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若插入数据位置不在表尾</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt;= L-&gt; <span class="number">1</span>ength)&#123;</span><br><span class="line">        <span class="comment">//将要插入位置后数据元素向后移动一位*/</span></span><br><span class="line">        <span class="keyword">for</span>(k = L-&gt; <span class="number">1</span>ength<span class="number">-1</span>;k &gt;=i<span class="number">-1</span>;k--)&#123;</span><br><span class="line">            L-&gt;data[k+<span class="number">1</span>] = L-&gt;data[k]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新元素插入</span></span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>] = e;</span><br><span class="line">    L-&gt;length++; </span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><strong>思路</strong></p>
<ul>
<li>删除位置不合理，抛出异常；</li>
<li>取出删除元素；</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动个位置；</li>
<li>表长减1。</li>
</ul>
<p>🌰<strong>离队</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	初始条件：顺序线性表L已存在，1 ≤ i ≤ ListLength(L)</span></span><br><span class="line"><span class="comment">	操作结果：删除L的第主个数据元素，并用e返回其值，L的长度减1</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="comment">//线性表为空</span></span><br><span class="line">   		<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length)&#123;</span><br><span class="line">    	<span class="comment">//删除位置不正确</span></span><br><span class="line">    	<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//如果删除不是最后位置</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; L-&gt;length)&#123;</span><br><span class="line">    	<span class="comment">//将删除位置后继元素前移</span></span><br><span class="line">    	<span class="keyword">for</span>(k = i;k &lt; L-&gt;<span class="number">1</span>ength;k++)&#123;</span><br><span class="line">    		L-&gt;data[k<span class="number">-1</span>] = L-&gt;data[k];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析插入和删除的时间复杂度</strong></p>
<p><strong>最好的情况</strong>，如果元素要插入到<strong>最后一个位置</strong>，或者删除最后一个元素，<strong>时间复杂度为O（1）</strong>,因为<strong>不需要移动元素</strong>的，就如同来了一个新人要正常排队，当然是<strong>排在最后</strong>，如果此时他又不想排了，他离开之后，不影响任何人</p>
<p><strong>最坏的情况</strong>，如果元素要插入到<strong>第一个位置</strong>或者删除第一个元素,意味着要<strong>移动所有的元素向后或者向前</strong>，这个<strong>时间复杂度为平均的情况</strong>，由于元素插入到第<code>ⅰ</code>个位置，或删除第<code>i</code>个元素，需要移动<code>n-i</code>个元素。每个位置插入或删除元素的<strong>可能性是相同</strong>的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终<strong>平均移动次数和最中间的那个元素的移动次数相等</strong>，为(n-1)/2</p>
<p>平均时间复杂度还是O(n),这说明<code>线性表</code>的<code>顺序存储结构</code>，在<strong>存、读数据</strong>时，不管是哪个位置，<strong>时间复杂度都是O(1)</strong>；而<strong>插入或删除</strong>时，<strong>时间复杂度都是O(n)</strong>,说明它<strong>比较适合元素个数不太变化</strong>，而<strong>更多是存取数据</strong>的应用。</p>
<p><strong>优点</strong></p>
<ul>
<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任一位置的元素</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>插入和删除操作需要移密动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间一位置的元素的容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p><strong>特点</strong></p>
<p>用一组<strong>任意的存储单元</strong>存储线性表的数据元素，这组存储单元<strong>可以是连续</strong>的，<strong>也可以是不连续</strong>的。意味着，这些数据元素可以存在内存未被占用的<strong>任意位置</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200705174507.png" alt="下载"></p>
<p>在<strong>顺序结构</strong>中，每个数据元素<strong>只需要存数据元素信息</strong>就可以了。现在<strong>链式结构</strong>中，除了要存数据元素信息外，还要存储它的<strong>后继元素的存储地址</strong></p>
<p>把<strong>存储数据元素信息</strong>的域称为<strong>数据域</strong>，把<strong>存储直接后继位置</strong>的域称为<strong>指针域</strong>。指针域中存储的信息称做<strong>指针或链。</strong>这两部分信息组成数据元素的存储映像，称为<strong>结点</strong>（Node）。</p>
<p>把链表中<strong>第一个结点的存储位置</strong>叫做<code>头指针</code>，整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，是上一个的后继指针指向的位置。想象一下，最后一个结点，它的指针为空  通常 <strong>NULL 或 “^”</strong>  </p>
<p>方便对链表进行操作,会在单链表的第一个节点称为<code>头节点</code>,它的<strong>数据域,可以不存储任何数据</strong>,但是也<strong>可以存储链表的长度</strong>，<code>指针域</code>存储指向<strong>第一个节点的的指针</strong></p>
<p><code>头指针</code>与<code>头结点</code></p>
<p><strong>头指针</strong>是指<code>链表</code><strong>指向第一个节点的指针</strong></p>
<ul>
<li>头指针具有<strong>标识作用</strong>，所以常用头指针被称为链表</li>
<li><strong>无论链表是否为空,头指针一定不为空</strong> ,<code>头指针</code>是<strong>链表必要元素</strong></li>
</ul>
<p><strong>头节点</strong>是为了操作<code>链表</code>放在第一个节点之前，数据域一般无意义(可存放链表长度)</p>
<ul>
<li>有了头结点，对于链表的第一个节点插入和删除就<strong>与其他节点操作方式无异</strong></li>
<li><strong>头节点不是链表的必要元素</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表的单链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="comment">//定义 LinkedList</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>与数组相似,<code>链表</code>也是一种<code>线性</code>数据结构,<code>链表</code>有两种类型：<code>单链表</code>和<code>双链表</code>。</p>
<ul>
<li>链表是以<code>节点</code>的方式来存储是<strong>链式存储</strong>,</li>
<li>每个节点包含<strong>data域(存储数据)</strong>，<strong>next域：指向下一个节点</strong></li>
<li>链表的各个<strong>节点不一定是连续存储</strong></li>
<li>链表分<strong>带头节点的链表</strong>和<strong>不带头节点的链表</strong>，根据实际的需求来确定</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a><strong>单链表</strong></h4><p>单链表中的<strong>每个结点不仅包含值，还包含链接到下一个结点的<code>引用字段</code></strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200704124949.png" alt="screen-shot-2018-04-12-at-152754"></p>
<p>单链表的创建</p>
<ul>
<li>Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglyListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SinglyListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    SinglyListNode *next;</span><br><span class="line">    SinglyListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在大多数情况下,使用头结点(第一个结点)来表示整个链表。</strong></p>
<p><strong>无法访问单链表中的随机元素</strong>。获得第 i 个元素,必须从<strong>头结点逐个遍历</strong>。 我们按<code>索引</code>来<code>访问元素</code>平均要花费 <code>O(N)</code>时间，其中 N 是链表的长度。 </p>
<p><strong>添加元素</strong></p>
<p>在给定的结点 <code>prev</code> 之后添加新值，我们应该：</p>
<ol>
<li>使用给定值初始化新结点 <code>cur</code></li>
</ol>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200704145009.png" alt="screen-shot-2018-04-17-at-161130"></p>
<p><strong>线性表是逻辑结构，顺序表和链表是存储结构。</strong></p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>大话数据结构</li>
<li>尚硅谷 数据结构(Java版)</li>
<li><a href="https://www.bilibili.com/video/BV1E4411H73v?from=search&amp;seid=10908307989250096091" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1E4411H73v?from=search&amp;seid=10908307989250096091</a></li>
<li><a href="https://www.cnblogs.com/wincai/p/5893475.html" target="_blank" rel="noopener">https://www.cnblogs.com/wincai/p/5893475.html</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指offer</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体和共用体</title>
    <url>/posts/d9a0/</url>
    <content><![CDATA[<h2 id="结构体基本介绍"><a href="#结构体基本介绍" class="headerlink" title="结构体基本介绍"></a>结构体基本介绍</h2><p><code>结构体</code>和<code>结构体变量</code>的区别和联系</p>
<ul>
<li><code>结构体</code>是<strong>自定义的数据类型</strong>，表示的是一种数据类型 (Game 是数据类型 name是变量)</li>
<li><code>结构体变量</code>代表一个具体变量 int price(int是数据类型 price是变量);</li>
</ul>
<p><strong>成员基本介绍</strong></p>
<ul>
<li><p><code>成员</code>或<code>结构体包含的变量</code> 说法不同</p>
</li>
<li><p>成员是结构体的一个组成部分，<strong>一般是基本数据类型</strong>、也可以是<code>数组</code>、<code>指针</code>、<code>结构体</code>等。</p>
</li>
</ul>
<p><strong>注意事项和细节说明</strong></p>
<ul>
<li>成员声明语法同变量 <code>数据类型</code>   <code>成员名</code></li>
<li>字段的类型可以为：<code>基本类型</code>、<code>数组或指针</code>、<code>结构体</code>等</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">  <span class="comment">//结构体名首字母大写</span></span><br><span class="line">  成员列表...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建结构体 Game 数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Game</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> price;</span><br><span class="line">        <span class="keyword">char</span> *time;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用结构体创建变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Game</span> <span class="title">game1</span>;</span></span><br><span class="line">    <span class="comment">//给变量的成员赋值</span></span><br><span class="line">    game1.name = <span class="string">"CyberPunk2077"</span>;</span><br><span class="line">    game1.price = <span class="number">298</span>;</span><br><span class="line">    game1.time = <span class="string">"2020.11.19"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Game</span> <span class="title">game2</span>;</span></span><br><span class="line">    game2.name = <span class="string">"Watch Dogs: Legion"</span>;</span><br><span class="line">    game2.price = <span class="number">298</span>;</span><br><span class="line">    game2.time = <span class="string">"2020.10.29"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"游戏名称:%s 价格:%d 发售时间:%s\n"</span>,game1.name,game1.price,game1.time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"游戏名称:%s 价格:%d 发售时间:%s"</span>,game2.name,game2.price,game2.time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200716163649.png" alt="image-20200716163618173"></p>
<h3 id="结构体的创建"><a href="#结构体的创建" class="headerlink" title="结构体的创建"></a>结构体的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">char</span> *time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用结构体创建变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> <span class="title">game1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体的同时定义结构体变量并初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">char</span> *time;</span><br><span class="line">&#125; game1 = &#123;<span class="string">"CyberPunk2077"</span>,<span class="number">298</span>,<span class="string">"2020.11.19"</span>&#125;,game2 = &#123;<span class="string">"Watch Dogs: Legion"</span>,<span class="number">298</span>,<span class="string">"2020.10.29"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体变量时整体赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">char</span> *time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> <span class="title">game1</span> = &#123;</span><span class="string">"CyberPunk2077"</span>,<span class="number">298</span>,<span class="string">"2020.11.19"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>错误示范</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">char</span> *time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Game</span> <span class="title">game1</span>;</span></span><br><span class="line">game1 = &#123;<span class="string">"CyberPunk2077"</span>,<span class="number">298</span>,<span class="string">"2020.11.19"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>结构体定义的变量的数量确定</strong>时可以使用<strong>匿名结构体</strong>方式创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">char</span> *time;</span><br><span class="line">&#125;game1,game2;</span><br></pre></td></tr></table></figure>

<h2 id="公用体基本介绍"><a href="#公用体基本介绍" class="headerlink" title="公用体基本介绍"></a>公用体基本介绍</h2><ul>
<li><code>共用体(Union)</code>属于<strong>构造类型</strong>，它可以<strong>包含多个类型不同的成员</strong>。和结构体非常类似，但是也有<strong>不同的地方共用体有时也被称为联合或者联合体</strong>，定义格式为</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> 共用体名&#123;</span><br><span class="line">成员列表...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>结构体</code>和<code>共用体</code>的<strong>区别</strong>在于：<code>结构体</code>的各个成员会<strong>占用不同的内存</strong>，<strong>互相之间没有影响</strong>；而<code>共用体</code>的所有成员<strong>占用同一段内存</strong>，<strong>修改一个成员会影响其余所有成员</strong>并<strong>以空间最大的成员为准</strong></li>
</ul>
<h3 id="共用体的创建"><a href="#共用体的创建" class="headerlink" title="共用体的创建"></a>共用体的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">    short m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> data d1,d2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">    short m;</span><br><span class="line">&#125;d1,d2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">    short m;</span><br><span class="line">&#125;d1,d2;</span><br></pre></td></tr></table></figure>

<p><strong>🌰举例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> data&#123; <span class="comment">// data 就是一个共用体(内存布局)， 包含三个成员, 共享数据空间, 该空间的大小以占用最大的成员为准</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	short m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义两个一个 共用体变量  a</span></span><br><span class="line">	<span class="keyword">union</span> data a; </span><br><span class="line">    <span class="comment">// 4, 4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(<span class="keyword">union</span> data));</span><br><span class="line">    <span class="comment">//16进制 ==&gt; 2进制存储在内存中 0100 0000(1个字节8位数字) </span></span><br><span class="line">	a.n = <span class="number">0x40</span>;</span><br><span class="line">    <span class="comment">//a.n ==&gt; 64 a.ch ==&gt; @ 根据ASCII表 找到64 对应的字符@ a.m==&gt;64 short也是整型并且字节数大于64储存的字节数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">    <span class="comment">//字符9 根据ASCII表找到对应的2进制 0011 1001存储在内存中 </span></span><br><span class="line">	a.ch = <span class="string">'9'</span>;</span><br><span class="line">    <span class="comment">//a.n ==&gt; 57 0011 1001覆盖了原先的0100 0000 a.m==&gt;57 short也是整型并且字节数大于57储存的字节数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">    <span class="comment">//16进制 ==&gt; 2进制存储在内存中 0010 0000 0101 1001(1个字节8位数字) </span></span><br><span class="line">	a.m = <span class="number">0x2059</span>;</span><br><span class="line">    <span class="comment">//a.n==&gt;8281 2进制==&gt;10进制输出 a.ch==&gt;Y ch只占一个字节 0101 1001 转化为10进制 89 对应ASCII表的字符Y</span></span><br><span class="line">    <span class="comment">//a.m ==&gt;8281 short也是整型并且字节数等于于8281存储的字节数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">    <span class="comment">//16进制 ==&gt; 2进制存储在内存中 (1个字节8位数字) 0011 1110 0010 0101 1010 1101 0101 0100</span></span><br><span class="line">	a.n = <span class="number">0x3E25AD54</span>;</span><br><span class="line">    <span class="comment">//a.n==&gt; 2进制==&gt;10进制输出1042656596 a.ch 只看最后一个字节存储的2进制0101 0100 转化为10进制 84 对应ASCII表的字符T</span></span><br><span class="line">    <span class="comment">//a.m==&gt; 44372只看最后两个字节存储的1010 1101 0101 0100 转换为10进制输出44382</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存图解</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/L0serH4/mycdn/img/20200717175628.png" alt="image-20200717175621397"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div class="btn-center">
<a class="btn-beautify button--animated outline green larger" href="https://www.bilibili.com/video/BV1qJ411z7Hf?p=147" target="_blank" rel="noopener" title="尚硅谷C语言入门"><i class="far fa-hand-point-right fa-fw"></i> 尚硅谷C语言入门 </a>
</div>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>结构体和共用体</tag>
      </tags>
  </entry>
</search>
